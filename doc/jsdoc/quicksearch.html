<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"models_User.js.html":{"id":"models_User.js.html","title":"Source: models/User.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: models/User.js /** * User.js * * @description :: TODO: You might write a short summary of how this model works * and what it represents here. * @docs :: http://sailsjs.org/#!documentation/models */ var crypto = require('crypto'); module.exports = { attributes : { username : { type : 'string', required : true, unique : true }, nickname : { type : 'string', required : true, }, password : { type : 'string', required : true }, role : { type : 'string', defaultsTo : '' }, projectId : { type : 'string', required : true }, status : { type : 'string', defaultsTo : '' }, flag1 : { type : 'integer', defaultsTo : 0 }, // Override toJSON method to remove password from API toJSON : function() { var obj = this.toObject(); // Remove the password object value delete obj.password; // return the new object without password return obj; } }, beforeCreate : function(user, cb) { var shasum = crypto.createHash('sha1'); shasum.update(user.password); var hashed = shasum.digest('hex'); user.password = hashed; cb(null, user); } }; × Search results Close "},"controllers_RoomController.js.html":{"id":"controllers_RoomController.js.html","title":"Source: controllers/RoomController.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: controllers/RoomController.js /** * RoomController * * @description :: Server-side logic for managing Rooms * @help :: See http://links.sailsjs.org/docs/controllers */ module.exports = { }; × Search results Close "},"controllers_UserController.js.html":{"id":"controllers_UserController.js.html","title":"Source: controllers/UserController.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: controllers/UserController.js /** * UserController * * @description :: Server-side logic for managing Users * @help :: See http://links.sailsjs.org/docs/controllers */ module.exports = { }; × Search results Close "},"models_Board.js.html":{"id":"models_Board.js.html","title":"Source: models/Board.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: models/Board.js /** * Board.js * * @description :: TODO: You might write a short summary of how this model works and what it represents here. * @docs :: http://sailsjs.org/#!documentation/models */ module.exports = { attributes: { title : {type : 'string', required : true}, description : {type : 'string'}, projectId : {type : 'string', required : true}, category : {type : 'string'}, version : {type : 'string', defaultsTo: '1.1'}, width : {type : 'integer', defaultsTo: 3840}, height : {type : 'integer', defaultsTo: 2160}, bgType : {type : 'string', defaultsTo: 'image'}, bgColor : {type : 'string', defaultsTo: ''}, bgImage : {type : 'string', defaultsTo: '/images/background/background02.gif'}, bgRepeatType : {type : 'string', defaultsTo: 'repeat'}, bgSepV : {type : 'integer', defaultsTo: 1}, bgSepH : {type : 'integer', defaultsTo: 1}, bgSepLineWidth : {type : 'integer', defaultsTo: 3}, bgSepLineColor : {type : 'string', defaultsTo: '#000000'}, ticketData : {type : 'string', defaultsTo: 'ticket_blue_small:Keep:true,ticket_pink_small:Problem:true,ticket_yellow_small:Try:true,ticket_white_small:Memo:true'}, } }; × Search results Close "},"models_Room.js.html":{"id":"models_Room.js.html","title":"Source: models/Room.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: models/Room.js /** * Room.js * * @description :: TODO: You might write a short summary of how this model works and what it represents here. * @docs :: http://sailsjs.org/#!documentation/models */ module.exports = { attributes: { } }; × Search results Close "},"models_Ticket.js.html":{"id":"models_Ticket.js.html","title":"Source: models/Ticket.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: models/Ticket.js /** * Ticket.js * * @description :: TODO: You might write a short summary of how this model works and what it represents here. * @docs :: http://sailsjs.org/#!documentation/models */ module.exports = { attributes: { boardId : { type : 'integer' }, createUser : { type: 'string' }, contents : { type: 'string' }, positionX : { type: 'string' }, positionY : { type: 'string' }, color : { type: 'string' }, ticketHeight : { type : 'integer' }, ticketWidth : { type : 'integer' } } }; × Search results Close "},"controllers_TicketController.js.html":{"id":"controllers_TicketController.js.html","title":"Source: controllers/TicketController.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: controllers/TicketController.js /** * TicketController * * @description :: Server-side logic for managing Tickets * @help :: See http://links.sailsjs.org/docs/controllers */ module.exports = { }; × Search results Close "},"policies_sessionAuth.js.html":{"id":"policies_sessionAuth.js.html","title":"Source: policies/sessionAuth.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: policies/sessionAuth.js /** * sessionAuth * * @description :: Simple policy to allow any authenticated user * Assumes that your login action in one of your controllers sets `req.session.authenticated = true;` * @docs :: http://sailsjs.org/#!documentation/policies * */ module.exports = function(req, res, next) { // User is allowed, proceed to the next policy, // or if this is the last policy, the controller if (req.session.authenticated) { return next(); } // User is not allowed // (default res.forbidden() behavior can be overridden in `config/403.js`) return res.forbidden('You are not permitted to perform this action.'); }; × Search results Close "},"responses_badRequest.js.html":{"id":"responses_badRequest.js.html","title":"Source: responses/badRequest.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: responses/badRequest.js /** * 400 (Bad Request) Handler * * Usage: * return res.badRequest(); * return res.badRequest(data); * return res.badRequest(data, 'some/specific/badRequest/view'); * * e.g.: * ``` * return res.badRequest( * 'Please choose a valid `password` (6-12 characters)', * 'trial/signup' * ); * ``` */ module.exports = function badRequest(data, options) { // Get access to `req`, `res`, &amp; `sails` var req = this.req; var res = this.res; var sails = req._sails; // Set status code res.status(400); // Log error to console if (data !== undefined) { sails.log.verbose('Sending 400 (&quot;Bad Request&quot;) response: \\n',data); } else sails.log.verbose('Sending 400 (&quot;Bad Request&quot;) response'); // Only include errors in response if application environment // is not set to 'production'. In production, we shouldn't // send back any identifying information about errors. if (sails.config.environment === 'production') { data = undefined; } // If the user-agent wants JSON, always respond with JSON if (req.wantsJSON) { return res.jsonx(data); } // If second argument is a string, we take that to mean it refers to a view. // If it was omitted, use an empty object (`{}`) options = (typeof options === 'string') ? { view: options } : options || {}; // If a view was provided in options, serve it. // Otherwise try to guess an appropriate view, or if that doesn't // work, just send JSON. if (options.view) { return res.view(options.view, { data: data }); } // If no second argument provided, try to serve the implied view, // but fall back to sending JSON(P) if no view can be inferred. else return res.guessView({ data: data }, function couldNotGuessView () { return res.jsonx(data); }); }; × Search results Close "},"responses_forbidden.js.html":{"id":"responses_forbidden.js.html","title":"Source: responses/forbidden.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: responses/forbidden.js /** * 403 (Forbidden) Handler * * Usage: * return res.forbidden(); * return res.forbidden(err); * return res.forbidden(err, 'some/specific/forbidden/view'); * * e.g.: * ``` * return res.forbidden('Access denied.'); * ``` */ module.exports = function forbidden (data, options) { // Get access to `req`, `res`, &amp; `sails` var req = this.req; var res = this.res; var sails = req._sails; // Set status code res.status(403); // Log error to console if (data !== undefined) { sails.log.verbose('Sending 403 (&quot;Forbidden&quot;) response: \\n',data); } else sails.log.verbose('Sending 403 (&quot;Forbidden&quot;) response'); // Only include errors in response if application environment // is not set to 'production'. In production, we shouldn't // send back any identifying information about errors. if (sails.config.environment === 'production') { data = undefined; } // If the user-agent wants JSON, always respond with JSON if (req.wantsJSON) { return res.jsonx(data); } // If second argument is a string, we take that to mean it refers to a view. // If it was omitted, use an empty object (`{}`) options = (typeof options === 'string') ? { view: options } : options || {}; // If a view was provided in options, serve it. // Otherwise try to guess an appropriate view, or if that doesn't // work, just send JSON. if (options.view) { return res.view(options.view, { data: data }); } // If no second argument provided, try to serve the default view, // but fall back to sending JSON(P) if any errors occur. else return res.view('403', { data: data }, function (err, html) { // If a view error occured, fall back to JSON(P). if (err) { // // Additionally: // • If the view was missing, ignore the error but provide a verbose log. if (err.code === 'E_VIEW_FAILED') { sails.log.verbose('res.forbidden() :: Could not locate view for error page (sending JSON instead). Details: ',err); } // Otherwise, if this was a more serious error, log to the console with the details. else { sails.log.warn('res.forbidden() :: When attempting to render error page view, an error occured (sending JSON instead). Details: ', err); } return res.jsonx(data); } return res.send(html); }); }; × Search results Close "},"responses_notFound.js.html":{"id":"responses_notFound.js.html","title":"Source: responses/notFound.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: responses/notFound.js /** * 404 (Not Found) Handler * * Usage: * return res.notFound(); * return res.notFound(err); * return res.notFound(err, 'some/specific/notfound/view'); * * e.g.: * ``` * return res.notFound(); * ``` * * NOTE: * If a request doesn't match any explicit routes (i.e. `config/routes.js`) * or route blueprints (i.e. &quot;shadow routes&quot;, Sails will call `res.notFound()` * automatically. */ module.exports = function notFound (data, options) { // Get access to `req`, `res`, &amp; `sails` var req = this.req; var res = this.res; var sails = req._sails; // Set status code res.status(404); // Log error to console if (data !== undefined) { sails.log.verbose('Sending 404 (&quot;Not Found&quot;) response: \\n',data); } else sails.log.verbose('Sending 404 (&quot;Not Found&quot;) response'); // Only include errors in response if application environment // is not set to 'production'. In production, we shouldn't // send back any identifying information about errors. if (sails.config.environment === 'production') { data = undefined; } // If the user-agent wants JSON, always respond with JSON if (req.wantsJSON) { return res.jsonx(data); } // If second argument is a string, we take that to mean it refers to a view. // If it was omitted, use an empty object (`{}`) options = (typeof options === 'string') ? { view: options } : options || {}; // If a view was provided in options, serve it. // Otherwise try to guess an appropriate view, or if that doesn't // work, just send JSON. if (options.view) { return res.view(options.view, { data: data }); } // If no second argument provided, try to serve the default view, // but fall back to sending JSON(P) if any errors occur. else return res.view('404', { data: data, loginInfo:{userName:'', roleDesc:''} }, function (err, html) { // If a view error occured, fall back to JSON(P). if (err) { // // Additionally: // • If the view was missing, ignore the error but provide a verbose log. if (err.code === 'E_VIEW_FAILED') { sails.log.verbose('res.notFound() :: Could not locate view for error page (sending JSON instead). Details: ',err); } // Otherwise, if this was a more serious error, log to the console with the details. else { sails.log.warn('res.notFound() :: When attempting to render error page view, an error occured (sending JSON instead). Details: ', err); } return res.jsonx(data); } return res.send(html); }); }; × Search results Close "},"responses_ok.js.html":{"id":"responses_ok.js.html","title":"Source: responses/ok.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: responses/ok.js /** * 200 (OK) Response * * Usage: * return res.ok(); * return res.ok(data); * return res.ok(data, 'auth/login'); * * @param {Object} data * @param {String|Object} options * - pass string to render specified view */ module.exports = function sendOK (data, options) { // Get access to `req`, `res`, &amp; `sails` var req = this.req; var res = this.res; var sails = req._sails; sails.log.silly('res.ok() :: Sending 200 (&quot;OK&quot;) response'); // Set status code res.status(200); // If appropriate, serve data as JSON(P) if (req.wantsJSON) { return res.jsonx(data); } // If second argument is a string, we take that to mean it refers to a view. // If it was omitted, use an empty object (`{}`) options = (typeof options === 'string') ? { view: options } : options || {}; // If a view was provided in options, serve it. // Otherwise try to guess an appropriate view, or if that doesn't // work, just send JSON. if (options.view) { return res.view(options.view, { data: data }); } // If no second argument provided, try to serve the implied view, // but fall back to sending JSON(P) if no view can be inferred. else return res.guessView({ data: data }, function couldNotGuessView () { return res.jsonx(data); }); }; × Search results Close "},"responses_serverError.js.html":{"id":"responses_serverError.js.html","title":"Source: responses/serverError.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: responses/serverError.js /** * 500 (Server Error) Response * * Usage: * return res.serverError(); * return res.serverError(err); * return res.serverError(err, 'some/specific/error/view'); * * NOTE: * If something throws in a policy or controller, or an internal * error is encountered, Sails will call `res.serverError()` * automatically. */ module.exports = function serverError (data, options) { // Get access to `req`, `res`, &amp; `sails` var req = this.req; var res = this.res; var sails = req._sails; // Set status code res.status(500); // Log error to console if (data !== undefined) { sails.log.error('Sending 500 (&quot;Server Error&quot;) response: \\n',data); } else sails.log.error('Sending empty 500 (&quot;Server Error&quot;) response'); // Only include errors in response if application environment // is not set to 'production'. In production, we shouldn't // send back any identifying information about errors. if (sails.config.environment === 'production') { data = undefined; } // If the user-agent wants JSON, always respond with JSON if (req.wantsJSON) { return res.jsonx(data); } // If second argument is a string, we take that to mean it refers to a view. // If it was omitted, use an empty object (`{}`) options = (typeof options === 'string') ? { view: options } : options || {}; // If a view was provided in options, serve it. // Otherwise try to guess an appropriate view, or if that doesn't // work, just send JSON. if (options.view) { return res.view(options.view, { data: data }); } // If no second argument provided, try to serve the default view, // but fall back to sending JSON(P) if any errors occur. else return res.view('500', { data: data }, function (err, html) { // If a view error occured, fall back to JSON(P). if (err) { // // Additionally: // • If the view was missing, ignore the error but provide a verbose log. if (err.code === 'E_VIEW_FAILED') { sails.log.verbose('res.serverError() :: Could not locate view for error page (sending JSON instead). Details: ',err); } // Otherwise, if this was a more serious error, log to the console with the details. else { sails.log.warn('res.serverError() :: When attempting to render error page view, an error occured (sending JSON instead). Details: ', err); } return res.jsonx(data); } return res.send(html); }); }; × Search results Close "},"controllers_AuthController.js.html":{"id":"controllers_AuthController.js.html","title":"Source: controllers/AuthController.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: controllers/AuthController.js /** * AuthController * * @module AuthController 認証コントローラー * @description :: Server-side logic for managing Auths * @help :: See http://links.sailsjs.org/docs/controllers */ var passport = require(&quot;passport&quot;); var logger = require('../Log.js').getLoggerWrapper(&quot;AuthController&quot;); function openLoginPage(req, res, message){ var loginInfo = { userId :&quot;&quot;, userName :&quot;&quot;, roleName:&quot;&quot;, roleDesc:&quot;&quot; }; if(message){ loginInfo.message = message; } res.view(&quot;auth/login&quot;, { loginInfo: loginInfo }); } module.exports = { login : function(req, res) { logger.trace(req, &quot;login called&quot;); openLoginPage(req, res, null); }, process : function(req, res) { logger.trace(req, &quot;process called&quot;); var datetime = Utility.getDateTime(); passport.authenticate('local', function(err, user, info) { if ((err) || (!user)) { logger.info(req, &quot;*** login NG[&quot; + err + &quot;]&quot;); openLoginPage(req, res, {type: &quot;warn&quot;, contents: &quot;ログインに失敗しました。&quot;}); return; } // 無効ユーザーのアカウントが利用された場合には、ログイン画面に再度遷移する。 if(user[0][&quot;flag1&quot;] !== 0){ logger.info(req, &quot;*** login NG: invalid user account[&quot; + JSON.stringify(user[0]) + &quot;]&quot;); openLoginPage(req, res, {type: &quot;warn&quot;, contents: &quot;ログインに失敗しました。&quot;}); return; } req.logIn(user, function(err) { // エラーが発生した場合には、ログイン画面に再度遷移する。 if (err) { logger.info(req, &quot;*** login ERR[&quot; + JSON.stringify(user[0]) + &quot;]&quot;); openLoginPage(req, res, {type: &quot;danger&quot;, contents: &quot;ログインに失敗しました。&quot;}); return; } logger.info(req, &quot;*** login OK[&quot; + JSON.stringify(user[0]) + &quot;]&quot;); req.session.passport[&quot;userId&quot;] = user[0][&quot;username&quot;]; req.session.passport[&quot;name&quot;] = user[0][&quot;nickname&quot;]; req.session.passport[&quot;role&quot;] = user[0][&quot;role&quot;]; req.session.passport[&quot;projectId&quot;] = user[0][&quot;projectId&quot;]; req.session.passport[&quot;modelId&quot;] = user[0][&quot;id&quot;]; return res.redirect('/dashboard'); }); })(req, res); }, logout : function(req, res) { var datetime = Utility.getDateTime(); logger.trace(req, &quot;logout called&quot;); req.logout(); if (req.session &amp;&amp; req.session.passport) { logger.info(req, &quot;*** logout[&quot; + JSON.stringify(req.session.passport) + &quot;]&quot;); req.session.passport[&quot;userId&quot;] = &quot;&quot;; req.session.passport[&quot;name&quot;] = &quot;&quot;; req.session.passport[&quot;role&quot;] = &quot;&quot;; req.session.passport[&quot;modelId&quot;] = &quot;&quot;; } openLoginPage(req, res, {type: &quot;success&quot;, contents: &quot;ログアウトしました。&quot;}); }, _config : {} }; × Search results Close "},"controllers_BoardController.js.html":{"id":"controllers_BoardController.js.html","title":"Source: controllers/BoardController.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: controllers/BoardController.js /** * BoardController * * @module BoardController ボードコントローラー * @description :: Server-side logic for managing Boards * @help :: See http://links.sailsjs.org/docs/controllers */ var logger = require('../Log.js').getLoggerWrapper(&quot;BoardController&quot;); var u = require('underscore'); var us = require('underscore.string'); /** * ブラウザから呼び出された場合に利用するコールバック関数. * * @param req * リクエスト * @param res * レスポンス * @param params * パラメータ */ function getBrowserCallback(req, res, params){ logger.trace(req, &quot;getCreateBoardCallbackUI start&quot;); var type = params.type; var data = params.data; logger.trace(req, &quot;結果処理コールバック関数呼び出し（ブラウザ）:&quot; + JSON.stringify(data)); switch(type){ case &quot;main&quot;: Utility.openMainPage(req, res, data); break; case &quot;stay&quot;: var loginInfo = Utility.getLoginInfo(req, res); loginInfo.message = data; return res.view(&quot;newboard/index&quot;, { loginInfo: loginInfo, title: req.param(&quot;title&quot;), category : req.param(&quot;category&quot;), selectedId : req.param(&quot;selectedId&quot;), desc: req.param('description') }); break; case &quot;stay2&quot;: var loginInfo = Utility.getLoginInfo(req, res); loginInfo.message = data; res.view(&quot;dashboard/editBoard&quot;, { // id: req.param(&quot;boardId&quot;), // loginInfo: loginInfo, // category: req.param(&quot;category&quot;), // categories: [], // title: req.param(&quot;title&quot;), // description: req.param('description') id: id, title :found[&quot;title&quot;], description:found[&quot;description&quot;], width: found[&quot;width&quot;], height: found[&quot;height&quot;], bgType:found[&quot;bgType&quot;], bgColor:found[&quot;bgColor&quot;], bgImage:found[&quot;bgImage&quot;], bgRepeatType: found[&quot;bgRepeatType&quot;], bgSepV: found[&quot;bgSepV&quot;], bgSepH: found[&quot;bgSepH&quot;], bgSepLineWidth: found[&quot;bgSepLineWidth&quot;], bgSepLineColor: found[&quot;bgSepLineColor&quot;], images: backgroundFileList, category: found[&quot;category&quot;] || &quot;&quot;, categories: categories, selectedId : req.param(&quot;selectedId&quot;), ticketTypeList : ticketTypeList, loginInfo: loginInfo }); break; default: logger.error(req, &quot;結果処理コールバックに与えられたタイプが想定外:[&quot; + type + &quot;]&quot;); } logger.trace(req, &quot;getCreateBoardCallbackUI end&quot;); } /** * RESTから呼び出された場合に利用するコールバック関数. * * @param req * リクエスト * @param res * レスポンス * @param params * パラメータ */ function getRESTCallback(req, res, params){ logger.trace(req, &quot;getCreateBoardCallbackREST start&quot;); var type = params.type; var data = params.data; logger.trace(req, &quot;結果処理コールバック関数呼び出し（REST）:&quot; + JSON.stringify(data)); // REST結果に加工 data = u.extend(data, { success: data[&quot;type&quot;] === &quot;success&quot; ? true : false, message: data[&quot;contents&quot;]}); // 結果として利用しない項目の削除 delete(data.type); delete(data.contents); res.json(data); logger.trace(req, &quot;getCreateBoardCallbackREST end&quot;); } /** * 結果処理コールバック関数取得.&lt;br&gt; * * ブラウザからの呼び出しか、RESTからの呼び出し化を判断し、適切なコールバック関数を返却する。 * * @param req * リクエスト * @param res * レスポンス * @returns 結果処理コールバック関数 */ function getCallback(req, res){ logger.trace(req, &quot;getCallback start&quot;); var loginInfo = Utility.getLoginInfo(req, res); // 処理実行がブラウザかRESTかに応じてコールバック関数を選択する。 logger.trace(req, &quot;アクセスモード:&quot;+loginInfo.mode); var cb; if(loginInfo.mode == &quot;browser&quot;){ cb = getBrowserCallback; } else { cb = getRESTCallback; } logger.trace(req, &quot;getCallback end&quot;); return cb; } function trim(req, trimKeys){ u.each(trimKeys, function(key){ var value = req.param(key); req.params[key] = Utility.trim(req, value); }); } function requiredItemCheck(req, res, requiredKeys, errorCb){ var nullKeys = []; u.each(requiredKeys, function(obj){ logger.debug(req, &quot;必須チェック:&quot;+obj.key+&quot;,&quot;+obj.name); var value = req.param(obj.key); logger.debug(req, &quot;値[&quot;+value+&quot;]&quot;); if(value == null || value === &quot;&quot;){ nullKeys.push(obj.name); } }); logger.debug(req, &quot;数[&quot;+JSON.stringify(nullKeys)+&quot;-&gt;&quot;+nullKeys.length+&quot;]&quot;); if(nullKeys.length &gt; 0){ // エラー用コールバックの実行 errorCb(req, res, nullKeys); return false; } return true; } function setDefaultValues(req, newObj, defaultValues){ u.each(defaultValues, function(v, k){ var value = req.param(k) if(value == null){ logger.debug(req, &quot;デフォルト値の補完:&quot; + k+&quot; -&gt; &quot;+ v); value = v; } newObj[k] = value; }); } function adminCheck(req, res, cb, loginInfo, message){ logger.debug(req, &quot;管理者権限チェック 開始&quot;); if(loginInfo[&quot;roleName&quot;] !== &quot;admin&quot;){ logger.debug(req, &quot;管理者権限がないためエラーとする。&quot;); cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: message } }); return false; } logger.debug(req, &quot;管理者権限チェック 終了&quot;); return true; } /** * ボード作成内部処理.&lt;br&gt; * * @param req * リクエスト * @param res * レスポンス * @param cb * 呼び出し方式（ブラウザ/REST）に応じて処理を分岐するためのコールバック関数 */ function createBoardInner(req, res, cb) { var loginInfo = Utility.getLoginInfo(req, res); // 管理者ロールでない場合にはボードを作成できない。 if(!adminCheck(req, res, cb, loginInfo, &quot;一般ユーザーはボードを作成できません。&quot;)){ return; }; // タイトルとカテゴリをトリムする。 var trimKeys = [&quot;title&quot;, &quot;category&quot;]; var requiredKeys = [{key: &quot;title&quot;, name: &quot;タイトル&quot;}]; var defaultValues = { &quot;description&quot;: &quot;&quot;, &quot;category&quot;: &quot;&quot;, &quot;version&quot;: &quot;1.1&quot;, &quot;width&quot;: 3840, &quot;height&quot;: 2160, &quot;bgType&quot;: &quot;image&quot;, &quot;bgColor&quot;: &quot;&quot;, &quot;bgImage&quot;: &quot;/images/background/common/background02.gif&quot;, &quot;bgRepeatType&quot;: &quot;repeat&quot;, &quot;bgSepV&quot;: 1, &quot;bgSepH&quot;: 1, &quot;bgSepLineWidth&quot;: 3, &quot;bgSepLineColor&quot;: &quot;#000000&quot;, &quot;ticketData&quot;: &quot;ticket_blue_small:Keep:true,ticket_pink_small:Problem:true,ticket_yellow_small:Try:true,ticket_white_small:Memo:true&quot;, }; trim(req, trimKeys); // 必須チェックエラーコールバック var errorCb = function(req, res, nullKeys){ cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;必須項目が未入力です：[&quot; + nullKeys + &quot;]&quot; } }); }; if(!requiredItemCheck(req, res, requiredKeys, errorCb)){ return; } // 値が未設定の場合には、デフォルト値を設定する。 var newObj = {}; setDefaultValues(req, newObj, defaultValues); // 内部設定項目 newObj[&quot;title&quot;] = req.param(&quot;title&quot;); newObj[&quot;projectId&quot;] = loginInfo[&quot;projectId&quot;], // 作成者のプロジェクトＩＤを引き継ぐ logger.debug(req, &quot;★オブジェクト：&quot;+JSON.stringify(newObj)); Board.create(newObj).exec(function(err, created){ if(err) { cb(req, res, { type: &quot;stay&quot;, data: { type: &quot;danger&quot;, contents: &quot;ボードの作成に失敗しました: &quot; + JSON.stringify(err) } }); return; } cb(req, res, { type: &quot;main&quot;, data: { type: &quot;success&quot;, contents: &quot;ボードを作成しました。［カテゴリ：&quot; + req.param(&quot;category&quot;) + &quot;, タイトル：&quot; + req.param(&quot;title&quot;) + &quot;］&quot;, board: created } }); }); } /** * ボード更新内部処理.&lt;br&gt; * * @param req * リクエスト * @param res * レスポンス * @param cb * 呼び出し方式（ブラウザ/REST）に応じて処理を分岐するためのコールバック関数 */ function updateBoardInner(req, res, cb) { logger.trace(req, &quot;updateBoardInner start&quot;); var loginInfo = Utility.getLoginInfo(req, res); // 管理者ロールでない場合にはボードを更新できない。 if(!adminCheck(req, res, cb, loginInfo, &quot;一般ユーザーはボード情報を更新できません。&quot;)){ return; }; // ボードIDが指定されていない場合にはエラーとする。 var requiredKeys = [ {key: &quot;boardId&quot;, name: &quot;ボードＩＤ&quot;} ]; // タイトルが空文字の場合には、エラーとする。 var title = req.param(&quot;title&quot;); if(title != null &amp;&amp; title.trim() === &quot;&quot;){ cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;空のタイトルに変更することはできません。]&quot; } }); return; }; // 必須チェックエラーコールバック var errorCb = function(req, res, nullKeys){ cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;必須項目が未入力です：[&quot; + nullKeys + &quot;]&quot; } }); }; if(!requiredItemCheck(req, res, requiredKeys, errorCb)){ return; } var boardId = req.param('boardId'); // 同一プロジェクトＩＤでない場合にはエラーとする。 Board.findOne(boardId).exec(function(err, found){ var loginInfo = Utility.getLoginInfo(req, res); if(err){ cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;ボード情報の更新に失敗しました: &quot; + JSON.stringify(err) } }); return; } if(loginInfo[&quot;projectId&quot;] != found[&quot;projectId&quot;]){ cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;ボード情報の更新に失敗しました（プロジェクトID不一致）&quot; } }); return; } // カテゴリ文字列をトリムする。 var trimKeys = [&quot;category&quot;]; trim(req, trimKeys); // 更新したい値を設定するオブジェクト var newObj = {}; // 変更対象項目キー配列 var keys = [ 'title', 'description', 'category', 'width', 'height', 'bgType', 'bgColor', 'bgImage', 'bgRepeatType', 'bgSepV', 'bgSepH', 'bgSepLineWidth', 'bgSepLineColor', 'ticketData' ]; // 送信された値を更新する。 u.each(keys, function(key){ if(req.param(key)){ newObj[key] = req.param(key); } }); // ボードの更新処理 Board.update(boardId, newObj).exec(function(err,created){ if(err) { cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;ボード情報の更新に失敗しました: &quot; + JSON.stringify(err) } }); return; } cb(req, res, { type: &quot;main&quot;, data: { type: &quot;success&quot;, contents: &quot;ボード情報を更新しました。&quot; } }); return; }); }); } /** * ボード削除処理 */ function deleteBoardInner(req, res, cb) { logger.trace(req, &quot;deleteBoardInner start&quot;); var loginInfo = Utility.getLoginInfo(req, res); // 管理者ロールでない場合にはボードを更新できない。 if(!adminCheck(req, res, cb, loginInfo, &quot;一般ユーザーはボード情報を更新できません。&quot;)){ return; }; // ボードIDが指定されていない場合にはエラーとする。 var requiredKeys = [ {key: &quot;boardId&quot;, name: &quot;ボードＩＤ&quot;} ]; // 必須チェックエラーコールバック var errorCb = function(req, res, nullKeys){ cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;必須項目が未入力です：[&quot; + nullKeys + &quot;]&quot; } }); }; if(!requiredItemCheck(req, res, requiredKeys, errorCb)){ return; } var boardId = req.param('boardId'); // 同一プロジェクトＩＤでない場合にはエラーとする。 Board.find({projectId: loginInfo[&quot;projectId&quot;], id: boardId}).exec(function(err, found){ var loginInfo = Utility.getLoginInfo(req, res); if(err) { cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;ボード情報の削除に失敗しました: &quot; + JSON.stringify(err) } }); return; } Board.destroy(boardId).exec(function(err, found2){ if(err || (found2 &amp;&amp; found2.length === 0)) { logger.error(req, &quot;ボード削除処理 失敗: [&quot; + boardId + &quot;,&quot;+ JSON.stringify(err) + &quot;]&quot;); cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;ボード削除に失敗しました[&quot; + boardId + &quot;]&quot; } }); return; } else { logger.info(req, &quot;ボード削除処理 成功: [&quot; + boardId + &quot;]&quot;); cb(req, res, { type: &quot;main&quot;, data: { type: &quot;success&quot;, contents: &quot;ボードを削除しました: [&quot; + found2[0][&quot;title&quot;] + &quot;]&quot; } }); return; } }); }); } /** * ボード一覧取得処理 */ function listBoardInner(req, res, cb) { logger.trace(req, &quot;listBoardInner start&quot;); var loginInfo = Utility.getLoginInfo(req, res); // 必須チェックエラーコールバック var errorCb = function(req, res, nullKeys){ cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;必須項目が未入力です：[&quot; + nullKeys + &quot;]&quot; } }); }; // クエリ条件 var queryCondition = {projectId: loginInfo[&quot;projectId&quot;]}; // ボードID, タイトルが指定されている場合、条件に追加する。 var conditionKeys = [&quot;id&quot;, &quot;title&quot;]; _.each(conditionKeys, function(key){ var value = req.param(key); if(value != null){ queryCondition[key] = value; } }); Board.find(queryCondition).exec(function(err, found){ var loginInfo = Utility.getLoginInfo(req, res); if(err) { cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;ボード一覧取得に失敗しました: &quot; + JSON.stringify(err) } }); return; } logger.info(req, &quot;ボード一覧取得処理 成功&quot;); cb(req, res, { type: &quot;main&quot;, data: { type: &quot;success&quot;, contents: &quot;ボード一覧を取得しました&quot;, board: found } }); return; }); } /** * チケット作成処理. * * @param req * リクエスト * @param res * レスポンス * @param cb * 結果処理コールバック * @param loginInfo * ログイン情報 * @param boardId * ボードＩＤ */ function createTicket(req, res, cb, loginInfo, boardId){ var userId = req.param('userId'); var socket = req.socket; var io = sails.io; var roomName = &quot;room_&quot;+boardId+&quot;_&quot;; // デフォルト値データ var defaultValues = { contents: &quot;&quot;, positionX: 0, positionY: 0, color: &quot;ticket_blue_small&quot;, ticketHeight: 170, ticketWidth: 244 }; var newObj = {}; setDefaultValues(req, newObj, defaultValues); newObj[&quot;boardId&quot;] = boardId; newObj[&quot;createUser&quot;] = userId; User.findOne(userId).exec(function(err, foundUser) { Ticket.create(newObj).exec(function(err, ticket) { if (err) { cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;danger&quot;, contents: &quot;チケット作成に失敗しました。&quot;+JSON.stringify(err) } }); } else { io.sockets.in(roomName).emit('message', { action: &quot;created&quot;, id: ticket.id, contents: ticket.contents, boardId: ticket.boardId, createUser : ticket.createUser, positionX: ticket.positionX, positionY: ticket.positionY, ticketHeight: ticket.ticketHeight, ticketWidth: ticket.ticketWidth, color: ticket.color, createdAt: ticket.createdAt, nickname : foundUser[&quot;nickname&quot;]}); cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;success&quot;, contents: &quot;チケット作成に成功しました。&quot;, ticket: ticket } }); } }); }); } /** * チケット削除処理. * * @param req * リクエスト * @param res * レスポンス * @param cb * 結果処理コールバック * @param loginInfo * ログイン情報 * @param boardId * ボードＩＤ */ function deleteTicket(req, res, cb, loginInfo, boardId){ var socket = req.socket; var io = sails.io; var roomName = &quot;room_&quot;+boardId+&quot;_&quot;; var id = req.param('id'); Ticket.findOne({boardId: boardId, id: id}).exec(function(err, found) { if(err){ cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;danger&quot;, contents: &quot;削除対象チケット取得に失敗しました。&quot; + JSON.stringify(err) } }); return; } Ticket.destroy({boardId: boardId, id: id}).exec(function(err2){ if(err2){ cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;danger&quot;, contents: &quot;チケットの削除に失敗しました。&quot; + JSON.stringify(err2) } }); return; } if(found){ io.sockets.in(roomName).emit('message', { action: &quot;destroyed&quot;, id : found.id }); cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;success&quot;, contents: &quot;チケットを削除しました。&quot; } }); } }); }); } /** * チケット更新処理. * * @param req * リクエスト * @param res * レスポンス * @param cb * 結果処理コールバック * @param loginInfo * ログイン情報 * @param boardId * ボードＩＤ */ function updateTicket(req, res, cb, loginInfo, boardId){ var socket = req.socket; var io = sails.io; var roomName = &quot;room_&quot;+boardId+&quot;_&quot;; var id = req.param('id'); var x = req.param('positionX'); var y = req.param('positionY'); var ticketHeight = req.param('ticketHeight'); var ticketWidth = req.param('ticketWidth'); var contents = req.param('contents'); var newObj = {}; var keys = [&quot;positionX&quot;, &quot;positionY&quot;, &quot;ticketHeight&quot;, &quot;ticketWidth&quot;, &quot;contents&quot;]; u.each(keys, function(key){ var value = req.param(key); if(value != null){ newObj[key] = value; } }); Ticket.update({boardId: boardId, id : id}, newObj).exec(function update(err, updated) { if(err){ cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;danger&quot;, contents: &quot;チケットの更新に失敗しました。&quot; + JSON.stringify(err) } }); return; } logger.info(req, &quot;チケット更新 成功: [&quot;+JSON.stringify(updated[0])+&quot;]&quot;); io.sockets.in(roomName).emit('message', { action : &quot;updated&quot;, id : updated[0].id, positionX: updated[0].positionX, positionY: updated[0].positionY, ticketHeight: updated[0].ticketHeight, ticketWidth : updated[0].ticketWidth, contents: updated[0].contents }); cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;success&quot;, contents: &quot;チケットを更新しました。&quot;, ticket: updated[0] } }); }); } /** * チケット移動処理. * * チケットをボードから別なボードに移動する。 * * @param req * リクエスト * @param res * レスポンス * @param cb * 結果処理コールバック * @param loginInfo * ログイン情報 * @param boardId * ボードＩＤ */ function moveTicket(req, res, cb, loginInfo, boardId){ var socket = req.socket; var io = sails.io; var roomName = &quot;room_&quot;+boardId+&quot;_&quot;; var id = req.param('id'); var nickname = req.param('nickname'); // 移動先ボード var dstBoardId = req.param('dstBoardId'); // 移動先ボードのプロジェクトＩＤがユーザーのプロジェクトＩＤに一致していない場合にはエラーとする。 Board.findOne(dstBoardId).exec(function(err, found){ if(err){ cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;danger&quot;, contents: &quot;チケット移動先ボードの取得に失敗しました。&quot;+JSON.stringify(err) } }); return } logger.debug(req, &quot;移動先ボードのプロジェクトＩＤチェック:&quot;+found[&quot;projectId&quot;] +&quot;,&quot;+ loginInfo[&quot;projectId&quot;]); if(found[&quot;projectId&quot;] !== loginInfo[&quot;projectId&quot;]){ cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;danger&quot;, contents: &quot;移動先ボードが存在しません。&quot; } }); return; } Ticket.update({boardId: boardId, id: id}, {boardId : dstBoardId}).exec(function update(err, updated){ if(err){ cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;danger&quot;, contents: &quot;チケットの移動に失敗しました。&quot; + JSON.stringify(err) } }); return; } var ticket = updated[0]; logger.debug(req, &quot;チケット移動 成功: [&quot;+JSON.stringify(ticket)+&quot;]&quot;); // 移動元ボードに対してメッセージ通知 io.sockets.in(roomName).emit('message',{action: &quot;destroyed&quot;, id : id}); // 移動先ボードに対してメッセージ通知 io.sockets.in(&quot;room_&quot; + dstBoardId).emit('message', { action: &quot;created&quot;, id: id, contents: ticket.contents, boardId: ticket.boardId, createUser : ticket.createUser, positionX: ticket.positionX, positionY: ticket.positionY, ticketHeight: ticket.ticketHeight, ticketWidth : ticket.ticketWidth, color: ticket.color, nickname : nickname }); cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;success&quot;, contents: &quot;チケットを移動しました。&quot; } }); }) }) } /** * チケット一覧取得処理 */ function listTicketInner(req, res, cb) { logger.trace(req, &quot;listTicketInner start&quot;); var loginInfo = Utility.getLoginInfo(req, res); // 必須チェックエラーコールバック var errorCb = function(req, res, nullKeys){ cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;必須項目が未入力です：[&quot; + nullKeys + &quot;]&quot; } }); }; // ボードID、もしくは、ボードタイトルが指定されていない場合にはエラーとする。 var boardId = req.param(&quot;boardId&quot;); var boardTitle = req.param(&quot;boardTitle&quot;); if(boardId == null &amp;&amp; boardTitle == null){ cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;ボードＩＤ(boardId)、もしくは、ボードタイトル(boardTitle)の入力が必要です&quot; } }); } // クエリ条件 var queryCondition = {projectId: loginInfo[&quot;projectId&quot;]}; // ボードID, タイトルが指定されている場合、条件に追加する。 if(boardId != null){ queryCondition[&quot;id&quot;] = boardId; } if(boardTitle != null){ queryCondition[&quot;title&quot;] = boardTitle; } logger.debug(req, &quot;チケット取得条件:&quot;+JSON.stringify(queryCondition)); Board.find(queryCondition).exec(function(err, found){ var loginInfo = Utility.getLoginInfo(req, res); if(err) { cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;ボード取得に失敗しました: &quot; + JSON.stringify(err) } }); return; } if(found.length == 0){ cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;指定したボードは存在しません&quot; } }); return; } // チケット一覧取得元ボード // チケットタイトルを条件とした場合には、複数のボードが取得される可能性があるが、先頭のものと対象とする。 var targetBoard = found[0]; logger.info(req, &quot;ボード取得処理 成功&quot;); Ticket.find({boardId: targetBoard[&quot;id&quot;]}).exec(function(err2, found2){ if(err2) { cb(req, res, { type: &quot;main&quot;, data: { type: &quot;danger&quot;, contents: &quot;チケット一覧の取得に失敗しました: &quot; + JSON.stringify(err2) } }); return; } cb(req, res, { type: &quot;main&quot;, data: { type: &quot;success&quot;, contents: &quot;チケット一覧を取得しました&quot;, ticket: found2 } }); return; }); }); } module.exports = { /** * リスナ登録 */ register : function(req, res) { var boardId = req.param('boardId'); logger.trace(req, &quot;register called: [&quot; + boardId + &quot;]&quot;); var socket = req.socket; var io = sails.io; // リスナ登録 var roomName = 'room_'+boardId+'_'; logger.debug(req, &quot;リスナ登録: [&quot; + roomName + &quot;]&quot;); socket.join(roomName); if(req.session.passport){ var userId = req.session.passport.userId; BoardUserManager.addBoardUser(req, roomName, userId); var usersInRoom = BoardUserManager.getBoardUserInfo(req, roomName); io.sockets.in(roomName).emit('message', {action : &quot;enter&quot;, userId: userId, users: usersInRoom}); } }, /** * ボード作成 */ createBoard : function(req, res) { var cb = getCallback(req, res); createBoardInner(req, res, cb); }, /** * ボード情報更新 */ updateBoard : function(req, res) { var cb = getCallback(req, res); updateBoardInner(req, res, cb); }, /** * ボード情報削除 */ deleteBoard : function(req, res) { var cb = getCallback(req, res); deleteBoardInner(req, res, cb); }, /** * ボード一覧取得 */ listBoard : function(req, res) { var cb = getCallback(req, res); listBoardInner(req, res, cb); }, /** * チケット共通処理. * * @param req * リクエスト * @param res * レスポンス */ process : function(req, res) { var loginInfo = Utility.getLoginInfo(req, res); // 結果処理コールバックを取得 var cb; logger.debug(req, &quot;モード[&quot;+loginInfo.mode+&quot;]&quot;); if(loginInfo.mode === &quot;rest&quot;){ cb = getRESTCallback; } else { cb = function(req, res, params){ logger.debug(req, &quot;チケット処理:&quot;+JSON.stringify(params)); }; } var actionType = req.param('actionType'); // チケット新規作成以外の場合には、チケットＩＤの必須チェックを行う。 if(actionType !== &quot;create&quot;){ var id = req.param('id'); if(id == null){ cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;danger&quot;, contents: &quot;チケットＩＤが指定されていません。&quot; } }); return; } } var boardId = req.param('boardId'); // ボードＩＤの必須チェック if(boardId == null || boardId === &quot;&quot;){ cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;danger&quot;, contents: &quot;ボードIDが指定されていません&quot; } }); return; } // ボードのプロジェクトＩＤがユーザーのプロジェクトＩＤに一致していない場合にはエラーとする。 Board.findOne(boardId).exec(function(err, found){ if(err){ cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;danger&quot;, contents: &quot;チケット作成ボードの取得に失敗しました。&quot;+JSON.stringify(err) } }); return } logger.debug(req, &quot;プロジェクトＩＤチェック:&quot;+found[&quot;projectId&quot;] +&quot;,&quot;+ loginInfo[&quot;projectId&quot;]); if(found[&quot;projectId&quot;] !== loginInfo[&quot;projectId&quot;]){ cb(req, res, { type: &quot;main&quot;, data:{ type: &quot;danger&quot;, contents: &quot;チケット作成ボードが存在しません。&quot; } }); return; } logger.debug(req, &quot;チケット処理:[&quot;+actionType+&quot;][&quot;+id+&quot;][&quot;+boardId+&quot;]&quot;); switch(actionType){ case &quot;create&quot;: // チケット作成 createTicket(req, res, cb, loginInfo, boardId); break; case &quot;destroy&quot;: deleteTicket(req, res, cb, loginInfo, boardId); break; case &quot;update&quot;: updateTicket(req, res, cb, loginInfo, boardId); break; case &quot;move&quot;: moveTicket(req, res, cb, loginInfo, boardId); break; default: logger.error(req, &quot;チケット処理 想定外のアクション:[&quot; + actionType + &quot;]&quot;); } }); }, /** * チケット一覧取得 */ listTicket : function(req, res) { var cb = getCallback(req, res); listTicketInner(req, res, cb); } } × Search results Close "},"controllers_DashboardController.js.html":{"id":"controllers_DashboardController.js.html","title":"Source: controllers/DashboardController.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: controllers/DashboardController.js /** * DashboardController * * @module DashboardController ボードコントローラー２ * @description :: Server-side logic for managing dashboards * @help :: See http://links.sailsjs.org/docs/controllers */ var u = require('underscore'); var us = require('underscore.string'); var fs = require('fs'); var path = require('path'); var logger = require('../Log.js').getLoggerWrapper(&quot;DashboardController&quot;); // 背景画像を格納するパス var BACKGROUND_REL_PATH = &quot;/images/background/&quot;; // 画像ファイルとして許容する拡張子 var IMAGE_FILE_EXTENSIONS = [&quot;JPG&quot;, &quot;GIF&quot;, &quot;PNG&quot;, &quot;BMP&quot;]; function getBackgroundDir(req, res){ var loginInfo = Utility.getLoginInfo(req, res); var projectId = loginInfo[&quot;projectId&quot;]; var path = './upload' + BACKGROUND_REL_PATH+ projectId + &quot;/&quot;; return path; } // 資産フォルダ var ASSETS = &quot;assets&quot;; // ファイルアップロードと同時に背景画像を変更したい場合にはtrueにする。 var flagChangeBackgroundImage = false; // 背景情報のデフォルト値 var BOARD_DEFAULT_VALUES = { version : '1.1', width : 3840, height : 2160, bgType : 'image', bgColor : '', bgImage : BACKGROUND_REL_PATH + 'background02.gif', bgRepeatType : 'repeat', bgSepV : 1, bgSepH : 1, bgSepLineWidth : 3, bgSepLineColor : '#000000', ticketData : 'ticket_blue_small:Keep:true,ticket_pink_small:Problem:true,ticket_yellow_small:Try:true,ticket_white_small:Memo:true' }; var ticketData0 = [ {id: &quot;ticket_blue_small&quot;, label: &quot;青（小）&quot;}, // {id: &quot;ticket_blue_big&quot;, label: &quot;青（大）&quot;}, {id: &quot;ticket_pink_small&quot;, label: &quot;ピンク（小）&quot;}, // {id: &quot;ticket_pink_big&quot;, label: &quot;ピンク（大）&quot;}, {id: &quot;ticket_yellow_small&quot;, label: &quot;黄（小）&quot;}, // {id: &quot;ticket_yellow_big&quot;, label: &quot;黄（大）&quot;}, {id: &quot;ticket_white_small&quot;, label: &quot;白（小）&quot;} // {id: &quot;ticket_white_big&quot;, label: &quot;白（大）&quot;}, // {id: &quot;ticket_brown_small&quot;, label: &quot;茶（小）&quot;}, // {id: &quot;ticket_brown_big&quot;, label: &quot;茶（大）&quot;}, // {id: &quot;ticket_gray_small&quot;, label: &quot;灰色（小）&quot;}, // {id: &quot;ticket_gray_big&quot;, label: &quot;灰（大）&quot;}, // {id: &quot;ticket_green_small&quot;, label: &quot;緑（小）&quot;}, // {id: &quot;ticket_green_big&quot;, label: &quot;緑（大）&quot;}, // {id: &quot;ticket_orange_small&quot;, label: &quot;オレンジ（小）&quot;}, // {id: &quot;ticket_orange_big&quot;, label: &quot;オレンジ（大）&quot;}, // {id: &quot;ticket_purple_small&quot;, label: &quot;紫（小）&quot;}, // {id: &quot;ticket_purple_big&quot;, label: &quot;紫（大）&quot;} ]; /** * 利用可能付箋タイプ一覧のデータを作成する。 * @param req * @param ticketData2 * @returns {String} */ function createTicketTypeString(req, ticketData2){ var ret = &quot;&quot;; var ticketData = createTicketDataArray(req, ticketData2); u.each(ticketData, function(d){ var id = d[&quot;id&quot;]; ret += '&lt;tr class=&quot;ticketDataRow&quot; id=&quot;' + id + '&quot;&gt;' +'&lt;td style=&quot;text-align:center;vertical-align:middle;&quot;&gt;' +'&lt;label for=&quot;check_' + id + '&quot; style=&quot;width:100%;&quot;&gt;' +'&lt;input class=&quot;ticketDataCheck&quot; id=&quot;check_' + id + '&quot; type=&quot;checkbox&quot; ' + d[&quot;state&quot;] + '/&gt;&lt;/label&gt;&lt;/td&gt;' +'&lt;td style=&quot;vertical-align:middle;&quot; class=&quot;ticketDataType&quot;&gt;' + d[&quot;label&quot;] + '&lt;/td&gt;' +'&lt;td style=&quot;vertical-align:middle;&quot;&gt;&lt;input class=&quot;ticketDataName&quot; style=&quot;width:100%;&quot; value=&quot;' + d[&quot;name&quot;] + '&quot;/&gt;&lt;/td&gt;'; +'&lt;/tr&gt;'; }); return ret; } /** * 利用可能付箋データ文字列を配列に変換する。 * @param ticketData2 利用可能付箋データ文字列 * @returns {Array} 利用可能付箋データ配列 */ function createTicketDataArray(req, ticketData2) { var ticketData = []; var items; if(ticketData2){ if(u.contains(ticketData2, &quot;,&quot;)){ items = ticketData2.split(&quot;,&quot;); } else { items = [ticketData2]; } } else { items = []; } var map = {}; u.each(items, function(item){ var items2 = item.split(&quot;:&quot;); map[items2[0]] = {name: items2[1], state: items2[2] === &quot;true&quot; ? &quot;checked&quot; : &quot;&quot;}; }); u.each(ticketData0, function(d){ var m = map[d[&quot;id&quot;]]; d[&quot;name&quot;] = m ? m[&quot;name&quot;] : &quot;&quot;; d[&quot;state&quot;] = m ? m[&quot;state&quot;] : &quot;&quot;; ticketData.push(d); }); return ticketData; } function showEditView(req, res, id, loginInfo){ logger.trace(req, &quot;showEditView called: [&quot; + id + &quot;]&quot;); // 管理者ロールでない場合には、ボード作成画面を表示しない。 if(loginInfo[&quot;roleName&quot;] !== &quot;admin&quot;){ logger.error(req, &quot;一般ユーザーは更新画面を表示できません。&quot;); message = {type: &quot;danger&quot;, contents: &quot;画面の表示に失敗しました。&quot;}; Utility.openMainPage(req, res, message); return; } Board.findOne(id).exec(function(err,found){ if(err || !found || loginInfo[&quot;projectId&quot;] !== found[&quot;projectId&quot;]) { logger.error(req, &quot;ボード編集時 ボード取得失敗: エラー発生: [&quot; + JSON.stringify(err) + &quot;]&quot;); Utility.openMainPage(req, res, {type: &quot;danger&quot;, contents: &quot;エラーが発生しました:&quot;+JSON.stringify(err)}); return; } else { logger.debug(req, &quot;編集対象ボード取得[&quot; + JSON.stringify(found) + &quot;]&quot;); fs.readdir(getBackgroundDir(req, res), function(err, files){ if (err) { throw err; } var backgroundFileList = []; files.filter(function(file){ return fs.statSync(getBackgroundDir(req, res) + file).isFile(); }).forEach(function (file) { backgroundFileList.push(BACKGROUND_REL_PATH + loginInfo[&quot;projectId&quot;]+&quot;/&quot; +file); }); logger.debug(req, backgroundFileList); var ticketData2 = found[&quot;ticketData&quot;] || BOARD_DEFAULT_VALUES[&quot;ticketData&quot;]; var ticketTypeList = createTicketTypeString(req, ticketData2); var successCb = function(categories){ res.view('dashboard/editBoard', { id: id, title :found[&quot;title&quot;], description:found[&quot;description&quot;], width: found[&quot;width&quot;], height: found[&quot;height&quot;], bgType:found[&quot;bgType&quot;], bgColor:found[&quot;bgColor&quot;], bgImage:found[&quot;bgImage&quot;], bgRepeatType: found[&quot;bgRepeatType&quot;], bgSepV: found[&quot;bgSepV&quot;], bgSepH: found[&quot;bgSepH&quot;], bgSepLineWidth: found[&quot;bgSepLineWidth&quot;], bgSepLineColor: found[&quot;bgSepLineColor&quot;], images: backgroundFileList, category: found[&quot;category&quot;] || &quot;&quot;, categories: categories, selectedId : req.param(&quot;selectedId&quot;), ticketTypeList : ticketTypeList, loginInfo: loginInfo }); } var errorCb = function(err){ logger.error(req, &quot;ボード情報の取得に失敗しました。&quot;+JSON.stringify(err)); message = {type: &quot;danger&quot;, contents: &quot;ボード情報の取得に失敗しました。&quot;}; Utility.openMainPage(req, res, message); }; Utility.getCategoryList(req, res, successCb, errorCb); }); } }); } function processDeleteImagePath(path){ var ret = null; if(path == null){ return ret; } if(!us.startsWith(path, &quot;/&quot;)){ return ret; } if(us.contains(path, &quot;..&quot;)){ return ret; } var items = path.split(&quot;/&quot;); if(items.length != 5){ return ret; } var dirName = items[3]; var fileName = items[4]; ret = {dirName: dirName, fileName: fileName}; return ret; } module.exports = { /** * ボード一覧画面を開く */ index : function(req, res) { logger.trace(req, &quot;index called&quot;); var loginInfo = Utility.getLoginInfo(req, res); var message; Board.find({projectId: loginInfo[&quot;projectId&quot;]}).sort({&quot;title&quot;:-1}).exec(function(err, found) { // ボードリストの取得に失敗した場合にはエラーメッセージを表示する。 if(err){ logger.error(req, &quot;ボード一覧画面オープン時にエラー発生[&quot; + JSON.stringify(err) +&quot;]&quot;); found = []; message = {type: &quot;danger&quot;, contents: &quot;ボード一覧画面の表示に失敗しました。&quot;}; loginInfo.message = message; res.view({ list: found, loginInfo: loginInfo }); return; } // 同期処理関数を作成 var wait = function (callbacks, done) { var counter = callbacks.length; if(counter &gt; 0){ var next = function() { if (--counter == 0) { done(); } }; for (var i=0; i &lt; callbacks.length; i++) { callbacks[i](next); }; } else { done(); } }; // 第1段階で終了すべき関数 var prerequisite = []; // ボードリストを取得した場合、必要に応じてボード情報のマイグレーションを行う。 // 取得したボード情報にバージョンが指定されていない場合にはマイグレーション対象とする。 var ngIds = []; for (var i = 0; i &lt; found.length; i++) { if (found[i][&quot;version&quot;] === undefined) { // i番目のボードに関する処理を即時評価とクロージャーで作成し、同期実行配列に追加する。 (function(num){ prerequisite.push(function(next) { logger.info(req, &quot;マイグレーション処理 開始&quot;); var board = found[num]; var boardId = board[&quot;id&quot;]; logger.info(req, &quot;マイグレーション対象ボード[&quot; + boardId + &quot;]&quot;); logger.info(req, &quot;マイグレーション前[&quot; + JSON.stringify(board) + &quot;]&quot;); // 値が未指定の場合にはデフォルト値を設定する。 var newBoard = u.defaults(_.clone(board), BOARD_DEFAULT_VALUES); delete newBoard[&quot;id&quot;]; delete newBoard[&quot;createdAt&quot;]; delete newBoard[&quot;updatedAt&quot;]; logger.info(req, &quot;マイグレーション後[&quot; + JSON.stringify(newBoard) + &quot;]&quot;); // テーブル内容の更新 Board.update(boardId, newBoard).exec(function(err2, updated) { if(err2) { logger.error(req, &quot;ボード情報のマイグレーションに失敗しました:[&quot; + boardId + &quot;]: &quot; + JSON.stringify(err2)); ngIds.push(boardId); } else { logger.info(req, &quot;ボード情報のマイグレーションに成功[&quot; + boardId + &quot;]&quot;); } logger.info(req, &quot;マイグレーション処理 終了&quot;); next(); }); }) })(i); } }; // 第２段階処理 var done = function() { logger.trace(req, &quot;ボード一覧画面表示処理 開始&quot;); if(ngIds.length &gt; 0){ loginInfo.message = {type: &quot;danger&quot;, contents: &quot;ボード情報のマイグレーションに失敗しました：[&quot; + ngIds + &quot;]&quot;}; } var categoryData = Utility.getCategoryMap(found); res.view({ categoryData: JSON.stringify(categoryData), category : req.param(&quot;category&quot;), selectedId : req.param(&quot;selectedId&quot;), loginInfo: loginInfo }); logger.trace(req, &quot;ボード一覧画面表示処理 終了&quot;); }; // 同期処理実行 wait(prerequisite, done); }); }, /** * ボード画面を開く */ openBoard2 : function(req, res) { var boardId = req.param(&quot;selectedId&quot;); logger.trace(req, &quot;openBoard2 called: [&quot;+boardId+&quot;]&quot;); var loginInfo = Utility.getLoginInfo(req, res); var message = null; //コンボボックスメニューHTML var comboMenu; // コンテクストメニューHTML var contextMenu = &quot;&quot;; if(!boardId){ logger.warn(req, &quot;ボードIDが存在しないためボード選択画面に遷移。&quot;); message = {type: &quot;warn&quot;, contents: &quot;ボードIDが指定されていません。&quot;}; Utility.openMainPage(req, res, message); return; } var wait = function (callbacks, done) { var counter = callbacks.length; if(counter &gt; 0){ var next = function() { if (--counter == 0) { done(); } }; for (var i=0; i &lt; callbacks.length; i++) { callbacks[i](next); }; } else { done(); } } Board.findOne(boardId).exec(function(err,found){ if(err){ logger.error(req, &quot;エラー発生: [&quot; + JSON.stringify(err) + &quot;]&quot;); message = {type: &quot;danger&quot;, contents: &quot;エラーが発生しました[&quot; + boardId + &quot;]&quot;}; Utility.openMainPage(req, res, message); return; } if(!found || loginInfo[&quot;projectId&quot;] !== found[&quot;projectId&quot;]) { logger.error(req, &quot;指定されたボードIDが存在しないため、ボード選択画面に遷移[&quot; + boardId + &quot;]&quot;); message = {type: &quot;warn&quot;, contents: &quot;指定したボードIDが存在しません[&quot; + boardId + &quot;]&quot;}; Utility.openMainPage(req, res, message); return; } Ticket.find({boardId : boardId}).exec(function(err2, tickets) { // 第1段階で終了すべき関数を格納する。 var prerequisite = []; // ニックネーム対応マップ（ユーザーIDとニックネームを対応させる） var userIdToNicknameMap = {}; // 全ユーザーリストを取得しニックネーム対応マップを作成する。 prerequisite.push(function(next) { // ログインユーザーと同一のプロジェクトＩＤをもつユーザーを取得 User.find({projectId: loginInfo[&quot;projectId&quot;]}).exec(function(err3, usersFound) { if(err3){ logger.error(req, &quot;チケットのユーザーIDの検索: エラー発生:&quot; + JSON.stringify(err3)); } else { u.each(usersFound, function(user){ userIdToNicknameMap[user[&quot;id&quot;]] = user[&quot;nickname&quot;]; }); } next(); }); }); var boardList; // ボードリスト取得処理関数を追加（移動先ボードリストとして利用） prerequisite.push(function(next) { Board.find({projectId: loginInfo[&quot;projectId&quot;]}) .where({ id: { 'not': boardId }}) .sort({&quot;title&quot;:-1}) .exec(function(err4, boards) { if(err4) { logger.error(req, &quot;ボードリストの取得: エラー発生: [&quot; + JSON.stringify(err4) + &quot;]&quot;); boardList = []; message = {type: &quot;danger&quot;, contents: &quot;エラーが発生しました。&quot;}; Utility.openMainPage(req, res, message); return; } else { boardList = boards || []; } // コールバック関数終了時にnext()を呼び出す。 next(); }); }) // 前提とするすべての処理が完了した後で実行する関数（ビュー生成関数のラッパー生成） var done = function (){ // DBから取得した利用可能付箋データから表示用データを抽出する。 var ticketData = found[&quot;ticketData&quot;] || BOARD_DEFAULT_VALUES[&quot;ticketData&quot;]; var ticketToUse = getTicketToUse(req, ticketData); // プルダウンメニューHTML設定 comboMenu = createComboMenu(ticketToUse); // コンテクストメニューHTML設定 contextMenu = createContextMenu(ticketToUse); // 各チケットにユーザーのニックネームを追加 u.each(tickets, function(ticket){ var createUser = ticket[&quot;createUser&quot;]; var nickname = userIdToNicknameMap[createUser]; ticket[&quot;nickname&quot;] = nickname ? nickname : &quot;none&quot;; }); var obj = { comboMenu: comboMenu, // プルダウンメニューHTML contextMenu: contextMenu, // コンテクストメニューHTML boardId: boardId, category : req.param(&quot;category&quot;), selectedId : req.param(&quot;selectedId&quot;), loginInfo: loginInfo, title : found[&quot;title&quot;], description: found[&quot;description&quot;], ticketData : tickets, boardList : boardList, list : tickets, width: found[&quot;width&quot;], height: found[&quot;height&quot;], bgImage: found[&quot;bgImage&quot;], bgRepeatType: found[&quot;bgRepeatType&quot;], bgSepV: found[&quot;bgSepV&quot;], bgSepH: found[&quot;bgSepH&quot;], bgSepLineWidth: found[&quot;bgSepLineWidth&quot;], bgSepLineColor: found[&quot;bgSepLineColor&quot;], canvasAppearance: Utility.getCanvasAppearance(found), boardAppearance: Utility.getBoardAppearance(found) }; res.view(obj); }; // 同期処理実行 wait(prerequisite, done); }); }); }, /** * ボード情報変更画面を開く */ editBoard : function(req, res) { var id = req.param(&quot;selectedId&quot;); logger.trace(req, &quot;editBoard: [&quot; + id + &quot;]&quot;); var loginInfo = Utility.getLoginInfo(req, res); showEditView(req, res, id, loginInfo); }, /** * ボード作成画面を開く */ createBoard : function(req, res) { logger.trace(req, &quot;createBoard&quot;); res.redirect('/newboard/index'); }, /** * ファイルのアップロード */ uploadImageFile: function (req, res) { logger.trace(req, &quot;uploadImageFile&quot;); // GET経由でのアップロードは許可しない。 if(req.method === 'GET'){ logger.warn(req, &quot;GETによるファイルアップロード要求が送られました。&quot;); return res.json({status: 'error', message : &quot;処理が不正です。&quot;}); } var uploadFile = req.file('uploadFile'); // 画像ファイルとして指定した拡張子以外の場合には、アップロードを行わない。 var fileName = uploadFile._files[0].stream.filename; logger.info(req, &quot;アップロード対象ファイル名:[&quot;+fileName+&quot;]&quot;); if(!isImageFile(fileName)){ logger.error(req, &quot;ファイルアップロード処理 失敗: 不正な拡張子[&quot; + fileName + &quot;]&quot;); var message = &quot;ファイル[&quot;+fileName+&quot;]のアップロードに失敗しました。&quot; + &quot;アップロードできる画像ファイルの拡張子は以下です：\\n&quot; + IMAGE_FILE_EXTENSIONS; return res.json({status: 'error', message : message}); } var boardId = req.param(&quot;selectedId&quot;); var loginInfo = Utility.getLoginInfo(req, res); var projectId = loginInfo[&quot;projectId&quot;]; logger.info(req, &quot;ファイルアップロード処理: [&quot; + boardId + &quot;][&quot; + uploadFile + &quot;][&quot;+projectId+&quot;]&quot;); // ファイルのアップロード処理 uploadFile.upload({dirname: getBackgroundDir(req, res)}, function onUploadComplete (err, files) { if (err) { logger.error(req, &quot;ファイルアップロード処理 失敗[&quot; + JSON.stringify(err) + &quot;]&quot;); return res.json({status: 'error', message : &quot;ファイルのアップロードに失敗しました。&quot;, error: err}); } // アップロードしたファイル名の取得 var filename = &quot;&quot;; if(files &amp;&amp; files.length &gt; 0){ filename = files[0].filename; } logger.info(req, &quot;ファイルアップロード処理 成功: [&quot; + filename + &quot;]&quot;); return res.json({status: 'success', src : BACKGROUND_REL_PATH + projectId + &quot;/&quot; + filename}); }); }, /** * ファイル削除処理 */ deleteImageFile: function (req, res) { logger.trace(req, &quot;deleteImageFile&quot;); // GET経由での削除は許可しない。 if(req.method === 'GET'){ logger.warn(req, &quot;GETによるファイル削除要求が送られました。&quot;); return res.json({status: 'error', message : &quot;処理が不正です。&quot;}); } var path = req.param(&quot;deleteImage&quot;); logger.debug(req, &quot;削除対象ファイル:[&quot; + path + &quot;]&quot;); // 削除対象ファイルのチェックを行う。 // チェックＯＫの場合には、画像フォルダ名とファイル名が返される。 var result = processDeleteImagePath(path); if(result == null){ logger.error(req, &quot;画像ファイル名が不正です:[&quot; + path + &quot;]&quot;); return res.json({status: 'error', message : &quot;画像ファイル名が不正です:[&quot; + path + &quot;]&quot;}); } // 画像ファイル名 var fileName = result.fileName; // 画像フォルダ名 var imageDir = result.dirName; // デフォルト画像（commonフォルダに入っている画像）は削除できない。 if(imageDir === &quot;common&quot;){ return res.json({status: 'error', message : &quot;デフォルト画像は削除できません。&quot;}); } logger.debug(req, &quot;ファイル削除処理: [&quot; + path + &quot;][&quot; + fileName + &quot;]&quot;); // 指定された画像ファイルを削除する。 var deletePath = getBackgroundDir(req, res) + fileName; var ret; fs.unlink(deletePath, function (err) { if (err) { logger.error(req, &quot;ファイル削除処理 失敗: [&quot; + JSON.stringify(err) + &quot;]&quot;); ret = {status: 'error', message : &quot;画像の削除に失敗しました。&quot;, error: err}; } else { logger.info(req, &quot;ファイル削除処理 成功: [&quot; + deletePath + &quot;]&quot;); ret = {status: 'success', src : BACKGROUND_REL_PATH + fileName}; } return res.json(ret); }); }, getImageFileList : function(req, res) { logger.trace(req, &quot;getImageFileList&quot;); var loginInfo = Utility.getLoginInfo(req, res); var projectId = loginInfo[&quot;projectId&quot;]; fs.readdir(getBackgroundDir(req, res), function(err, files){ if (err) { logger.error(req, &quot;画像ファイルリスト取得処理 失敗: [&quot; + JSON.stringify(err) + &quot;]&quot;); return res.json({status: 'error', error: err}); } // デフォルト背景画像 var defaultImages = [&quot;background02.gif&quot;, &quot;kpt.png&quot;, &quot;todo.gif&quot;]; var backgroundFileList = []; // デフォルト画像を追加 u.each(defaultImages, function(fileName){ backgroundFileList.push(BACKGROUND_REL_PATH + &quot;common/&quot; + fileName); }); files.filter(function(file){ // .で始まるファイルは表示対象外とする。 return fs.statSync(getBackgroundDir(req, res) + file).isFile() &amp;&amp; isImageFile(file); }).forEach(function (file) { backgroundFileList.push(BACKGROUND_REL_PATH + projectId +&quot;/&quot;+file); }); logger.debug(req, &quot;画像ファイルリスト取得処理 成功: [&quot; + backgroundFileList + &quot;]&quot;); return res.json({status: 'success', images: backgroundFileList}); }); } }; /** * 画像ファイルか否かを判定する。 * @param file ファイル名 * @returns 画像ファイルであればtrue, そうでない場合はfalse. */ function isImageFile(file){ if(us.startsWith(file, &quot;.&quot;) || file.indexOf('.') &lt; 0){ return false; } var ext = path.extname(file).toUpperCase(); ext = us.strRightBack(ext, &quot;.&quot;); var ret = u.contains(IMAGE_FILE_EXTENSIONS, ext); return ret; } /** * チケット個別スタイルを生成 * @param list チケットタイプリスト * @returns {String} スタイル文字列 */ function createCss(ticketTypeList){ var ret = &quot;&quot;; u.each(ticketTypeList, function(ticketType){ ret += createCssOfImage(ticketType); }); return ret; } /** * チケット個別スタイル情報ファイルの内容からスタイルHTMLを作成する。 * * 各行の先頭にクラス名を追加する。空行は無視する。 */ function addMainClassName(mainClassName, contents){ var lines = contents.replace(/\\r/g, &quot;&quot;).split(&quot;\\n&quot;); var ret = u.map(lines, function(line){ if(/^\\s*$/.test(line)){ //チケット空行のためスキップ return &quot;&quot;; } else { return mainClassName + line; } }).join('\\r\\n'); return ret; } /** * チケット単位の個別スタイル生成 * @param ticketType チケットタイプ * @returns {String} スタイル文字列 */ function createCssOfImage(ticketType){ var imageFileName = ticketType[&quot;imageFileName&quot;]; var contents = ticketType[&quot;contents&quot;]; var className = imageFileName.substring(0, imageFileName.indexOf(&quot;.&quot;)); var ret = &quot;&quot;; if(contents){ ret += addMainClassName(&quot;.&quot; + className, contents); } return ret; } /** * コンボボックスメニューHTML作成 * @param displayTickets 対象ボードで利用可能なチケットタイプのリスト * @returns HTML文字列 */ function createComboMenu(displayTickets){ var ret = u.map(displayTickets, function(displayTicket){ return '&lt;option value=&quot;'+ displayTicket.name + '&quot;&gt;'+ displayTicket.display + '&lt;/option&gt;'; }).join(&quot;\\r\\n&quot;); return ret + &quot;\\r\\n&quot;; } /** * コンテクストメニューHTML作成 * @param displayTickets 対象ボードで利用可能なチケットタイプのリスト * @returns HTML文字列 */ function createContextMenu(displayTickets){ var ret = u.map(displayTickets, function(item){ return '{title: &quot;'+item.display+'&quot;, cmd: &quot;'+item.name+'&quot;}'; }).join(&quot;\\r\\n,&quot;); return ret; } function getTicketToUse(req, ticketData){ var array = createTicketDataArray(req, ticketData); // stateが&quot;checked&quot;の要素を抽出する。 var ret = []; u.each(array, function(elem) { if(elem[&quot;state&quot;] === &quot;checked&quot;){ ret.push({name: elem[&quot;id&quot;], display: elem[&quot;name&quot;]}); } }); return ret; } × Search results Close "},"controllers_NewBoardController.js.html":{"id":"controllers_NewBoardController.js.html","title":"Source: controllers/NewBoardController.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: controllers/NewBoardController.js /** * NewBoardController * * @module NewBoardController ボード新規作成コントローラー * @description :: Server-side logic for managing Newboards * @help :: See http://links.sailsjs.org/docs/controllers */ var logger = require('../Log.js').getLoggerWrapper(&quot;NewBoardController&quot;); module.exports = { index : function(req, res) { logger.trace(req, &quot;index&quot;); var loginInfo = Utility.getLoginInfo(req, res); // 管理者ロールでない場合には、ボード作成画面を表示しない。 if(loginInfo[&quot;roleName&quot;] !== &quot;admin&quot;){ logger.error(req, &quot;一般ユーザーは新規作成画面を表示できません。&quot;); message = {type: &quot;danger&quot;, contents: &quot;画面の表示に失敗しました。&quot;}; Utility.openMainPage(req, res, message); return; } var successCb = function(categories){ res.view(&quot;newboard/index&quot;, { loginInfo: loginInfo, title: &quot;&quot;, desc: &quot;&quot;, category: &quot;&quot;, categories: categories }); } var errorCb = function(err){ logger.error(req, &quot;ボード情報の取得に失敗しました。&quot; + JSON.stringify(err)); message = {type: &quot;danger&quot;, contents: &quot;ボード情報の取得に失敗しました。&quot;}; Utility.openMainPage(req, res, message); }; Utility.getCategoryList(req, res, successCb, errorCb); } }; × Search results Close "},"controllers_RESTController.js.html":{"id":"controllers_RESTController.js.html","title":"Source: controllers/RESTController.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: controllers/RESTController.js /** * RESTController * * @module RESTController RESTコントローラー * @description :: Server-side logic for managing Auths * @help :: See http://links.sailsjs.org/docs/controllers */ var logger = require('../Log.js').getLoggerWrapper(&quot;RESTController&quot;); var jwt = require('jsonwebtoken'); var passport = require('passport'); var crypto = require('crypto'); var u = require('underscore'); var us = require('underscore.string'); var BoardController = require('./BoardController'); var tokenSecret = &quot;secretissecet&quot;; // TODO: どのように持つか？ /** * REST認証処理.&lt;br&gt; * * ユーザーID, パスワード認証を行う。 * * @param username ユーザーID * @param password パスワード * @param cb コールバック処理 */ function authenticate(username, password, cb){ // ユーザー名でユーザオブジェクトを検索し、パスワードが一致するか確認する。 User.findByUsername(username).exec(function(err, user) { var result = {}; if (err) { result.success = false; result.message = &quot;認証時にエラーが発生しました[&quot; + err + &quot;]&quot;; cb(result); return; } if (!user || user.length &lt; 1) { result.success = false; result.message = &quot;ユーザー[&quot;+username+&quot;]は存在しません&quot;; cb(result); return; } var shasum = crypto.createHash('sha1'); shasum.update(password); var hashed = shasum.digest('hex'); if (hashed === user[0].password) { sails.log.debug(&quot;user[0]=&quot;+JSON.stringify(user[0])); // ユーザーが無効の場合、エラーを返す。 if(user[0].flag1 !== 0){ result.success = false; result.message = &quot;ユーザー[&quot;+username+&quot;]は無効です。&quot;; } else { result.success = true; result.projectId = user[0].projectId; result.userId = user[0].id; result.message = &quot;認証成功[&quot;+username+&quot;]&quot;; } } else { result.success = false; result.message = &quot;パスワードが正しくありません[&quot;+username+&quot;]&quot;; } cb(result); }); } /** * 認証トークンの妥当性検証.&lt;br&gt; * * 認証トークンをデコードし、妥当性を検証する。 * エラーが発生した場合には、第１引数にエラー内容を設定してコールバック関数を実行。 * 妥当である場合には、第２引数にデコード結果を設定してコールバック関数を実行。 * * @param req リクエスト * @param cb コールバック関数 */ function authenticateToken(req, cb){ var token = req.param(&quot;token&quot;); if(token){ // TODO: 暫定的に有効期限をチェックしないようにしている。 jwt.verify(token, tokenSecret, {ignoreExpiration: true}, function(err, decoded){ if(err){ cb({message: &quot;認証に失敗しました&quot;}, null); return; } // 認証に成功した場合には、ユーザーの情報を取得する。 var username = decoded[&quot;user&quot;]; User.findByUsername(username).exec(function(err, user) { if(err || user == null || user.length &lt; 1){ cb({message: &quot;ユーザー情報の取得に失敗しました&quot;}, null); return; } var userInfo = user[0]; var info = { id: &quot;&quot;, userId: userInfo.id, userName: userInfo.nickname, roleName: userInfo.role, roleDesc : &quot;&quot;, projectId: userInfo.projectId, mode: &quot;rest&quot; }; decoded[&quot;info&quot;] = info; cb(null, decoded); return; }); }); } else { cb({message: &quot;トークンが不正です&quot;}, null); } } function getTicketProcessCallback(req, res, actionType){ return function(err, data){ logger.info(req, &quot;err:&quot;+JSON.stringify(err)); logger.info(req, &quot;data:&quot;+JSON.stringify(data)); if(err){ return res.json({message : &quot;チケット処理失敗&quot;}); } // アクションタイプを設定する req.params.actionType = actionType; // トークンデータからuserIdを取得する。 req.params.userId = data.info.userId; // トークデータから取得したユーザー情報をリクエストに追加 req.rest = data.info; // チケット関連処理 BoardController.process(req, res); }; } module.exports = { /** * 認証トークン生成.&lt;br&gt; * * POSTで送られたユーザー名、パスワードから認証トークンを生成する。 * */ getToken : function(req, res) { logger.trace(req, &quot;getToken start&quot;); var projectId = req.param(&quot;projectId&quot;); var user = req.param(&quot;user&quot;); var password = req.param(&quot;password&quot;); // projectId, user, passwordのいずれかが未設定の場合、エラーを返却。 if(projectId == null || user == null || password == null){ return res.json({ success: false, message: &quot;projectId, user, passwordが指定されていません&quot; }); } // 認証処理に渡すコールバック関数 var cb = function(result){ logger.trace(req, &quot;パスワード認証結果:&quot; + JSON.stringify(result)); // 認証失敗の場合、エラーを返却 if(!result || !result[&quot;success&quot;]){ return res.json(result); } // プロジェクトＩＤが一致しない場合には、エラーとする。 if(result[&quot;projectId&quot;] !== projectId){ return res.json({ success: false, message: &quot;認証に失敗しました。&quot; }) } // 認証トーク作成 var token = jwt.sign( { user: user, userId: result[&quot;userId&quot;] }, tokenSecret, { expiresIn: '180m' // TODO: 暫定的な設定値 }); logger.trace(req, &quot;getToken end:&quot;+ JSON.stringify(token)); res.json({ success: true, message: &quot;OK&quot;, token: token}); }; logger.trace(req, &quot;ユーザーID:[&quot; + user + &quot;]&quot;); authenticate(user, password, cb); }, /** * チケット作成API. */ createTicket : function(req, res) { logger.info(req, &quot;createTicket called&quot;); var cb = getTicketProcessCallback(req, res, &quot;create&quot;); authenticateToken(req, cb); }, /** * チケット削除API. */ deleteTicket : function(req, res) { logger.info(req, &quot;deleteTicket called&quot;); var cb = getTicketProcessCallback(req, res, &quot;destroy&quot;); authenticateToken(req, cb); }, /** * チケット更新API. */ updateTicket : function(req, res) { logger.info(req, &quot;updateTicket called&quot;); var cb = getTicketProcessCallback(req, res, &quot;update&quot;); authenticateToken(req, cb); }, /** * チケット移動API. */ moveTicket : function(req, res) { logger.info(req, &quot;moveTicket called&quot;); var cb = getTicketProcessCallback(req, res, &quot;move&quot;); authenticateToken(req, cb); }, /** * ボード作成API. */ createBoard : function(req, res) { logger.info(req, &quot;createBoard called&quot;); var cb = function(err, data){ logger.info(req, &quot;err:&quot;+JSON.stringify(err)); logger.info(req, &quot;data:&quot;+JSON.stringify(data)); if(err){ return res.json({ success: false, message : &quot;ボード作成失敗&quot; }); } req.rest = data.info; BoardController.createBoard(req, res); }; authenticateToken(req, cb); }, /** * ボード更新API. */ updateBoard : function(req, res) { logger.info(req, &quot;updateBoard called&quot;); var cb = function(err, data){ logger.info(req, &quot;err:&quot;+JSON.stringify(err)); logger.info(req, &quot;data:&quot;+JSON.stringify(data)); if(err){ return res.json({ success: false, message : &quot;ボード更新失敗&quot; }); } req.rest = data.info; BoardController.updateBoard(req, res); }; authenticateToken(req, cb); }, /** * ボード削除API. */ deleteBoard : function(req, res) { logger.info(req, &quot;deleteBoard called&quot;); var cb = function(err, data){ logger.info(req, &quot;err:&quot;+JSON.stringify(err)); logger.info(req, &quot;data:&quot;+JSON.stringify(data)); if(err){ return res.json({ success: false, message : &quot;ボード削除失敗&quot; }); } req.rest = data.info; BoardController.deleteBoard(req, res); }; authenticateToken(req, cb); }, /** * ボード一覧取得API. * * &lt;b&gt;REST API利用方法&lt;/b&gt; * &lt;pre&gt; * URL: http://(IPアドレス):(ポート番号)/api/board * * アクション: GET * * 入力項目 * &lt;table border=1&gt; * &lt;tr style=&quot;background-color: #dfd&quot;&gt;&lt;td&gt;キー&lt;/td&gt;&lt;td&gt;説明&lt;/td&gt;&lt;td&gt;必須&lt;/td&gt;&lt;td&gt;備考&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;token&lt;/td&gt;&lt;td&gt;認証トークン&lt;/td&gt;&lt;td&gt;○&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;id&lt;/td&gt;&lt;td&gt;ボードID&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;指定したボードIDをもつボードのみ取得&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;title&lt;/td&gt;&lt;td&gt;ボードタイトル&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;指定したタイトルをもつボードのみ取得&lt;/td&gt;&lt;/tr&gt; * &lt;/table&gt; * 出力項目 * &lt;table border=1&gt; * &lt;tr style=&quot;background-color: #dfd&quot;&gt;&lt;td&gt;キー&lt;/td&gt;&lt;td&gt;説明&lt;/td&gt;&lt;td&gt;備考&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;success&lt;/td&gt;&lt;td&gt;処理結果。処理に成功した場合はtrue、それ以外の場合はfalse.&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;message&lt;/td&gt;&lt;td&gt;結果メッセージ&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;board&lt;/td&gt;&lt;td&gt;指定したプロジェクトに存在するボード情報リスト&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; * &lt;/table&gt; * &lt;/pre&gt; */ listBoard : function(req, res) { logger.info(req, &quot;listBoard called&quot;); var cb = function(err, data){ logger.info(req, &quot;err:&quot;+JSON.stringify(err)); logger.info(req, &quot;data:&quot;+JSON.stringify(data)); if(err){ return res.json({ success: false, message : &quot;ボード一覧取得失敗:&quot;+err.message }); } req.rest = data.info; BoardController.listBoard(req, res); }; authenticateToken(req, cb); }, /** * チケット一覧取得API. *&lt;pre&gt; * URL: http://(IPアドレス):(ポート番号)/api/ticket * * アクション: GET * * 入力必須項目 * &lt;table border=1&gt; * &lt;tr style=&quot;background-color: #dfd&quot;&gt;&lt;td&gt;キー&lt;/td&gt;&lt;td&gt;説明&lt;/td&gt;&lt;td&gt;必須&lt;/td&gt;&lt;td&gt;備考&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;token&lt;/td&gt;&lt;td&gt;認証トークン&lt;/td&gt;&lt;td&gt;○&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;boardId&lt;/td&gt;&lt;td&gt;ボードID&lt;/td&gt;&lt;td&gt;＊１&lt;/td&gt;&lt;td rowspan=2&gt;＊１: ボードID、もしくは、ボードタイトルのいずれかが必要&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;boardTitle&lt;/td&gt;&lt;td&gt;ボードタイトル&lt;/td&gt;&lt;td&gt;＊１&lt;/td&gt;&lt;/tr&gt; * &lt;/table&gt; * 出力項目 * &lt;table border=1&gt; * &lt;tr style=&quot;background-color: #dfd&quot;&gt;&lt;td&gt;キー&lt;/td&gt;&lt;td&gt;説明&lt;/td&gt;&lt;td&gt;備考&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;success&lt;/td&gt;&lt;td&gt;処理結果。処理に成功した場合はtrue、それ以外の場合はfalse.&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;message&lt;/td&gt;&lt;td&gt;結果メッセージ&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;ticket&lt;/td&gt;&lt;td&gt;指定したボードに存在するチケット情報リスト&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; * &lt;/table&gt; * 実行例 * curl &quot;http://localhost:1337/api/board?token=(認証トークン文字列)&amp;projectId=P01&quot; * &lt;/pre&gt; */ listTicket : function(req, res) { logger.info(req, &quot;listTicket called&quot;); var cb = function(err, data){ logger.info(req, &quot;err:&quot;+JSON.stringify(err)); logger.info(req, &quot;data:&quot;+JSON.stringify(data)); if(err){ return res.json({ success: false, message : &quot;チケット一覧取得失敗:&quot;+err.message }); } req.rest = data.info; BoardController.listTicket(req, res); }; authenticateToken(req, cb); } }; × Search results Close "},"controllers_UserManageController.js.html":{"id":"controllers_UserManageController.js.html","title":"Source: controllers/UserManageController.js","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Source: controllers/UserManageController.js /** * UserManageController * * @module UserManageController ユーザー管理コントローラー * @description :: Server-side logic for managing Usermanages * @help :: See http://links.sailsjs.org/docs/controllers */ var crypto = require('crypto'); var u = require('underscore'); var logger = require('../Log.js').getLoggerWrapper(&quot;UserManageController&quot;); /** * ユーザー管理画面を開く */ function openUserManageIndexPage(req, res, message){ // 管理者はユーザー管理画面を開くことができる。 // 管理者以外がユーザー管理画面を開こうとした場合には、メッセージを表示して、メイン画面に遷移する。 var loginInfo = Utility.getLoginInfo(req, res); if(message){ loginInfo.message = message; } if(loginInfo[&quot;roleName&quot;] === &quot;admin&quot;){ User.find({projectId: loginInfo[&quot;projectId&quot;]}).sort('username').exec(function(err, usersFound) { if(err || !usersFound){ logger.error(req, &quot;ユーザー管理画面オープン 失敗: [&quot; + JSON.stringify(err) + &quot;]&quot;); loginInfo.message = {type: &quot;danger&quot;, contents: &quot;システムエラーが発生しました。&quot;}; usersFound = []; } var userNames = u.pluck(usersFound, &quot;username&quot;); logger.debug(req, &quot;ユーザー管理画面オープン 成功: [&quot; + userNames + &quot;]&quot;); res.view(&quot;usermanage/index&quot;, { users: usersFound, loginInfo: loginInfo }); }); } else { logger.warn(req, &quot;ユーザー管理画面オープン 失敗: [管理者権限なし]&quot;); Utility.openMainPage(req, res, {type: &quot;warn&quot;, contents:&quot;ユーザー管理画面にアクセスできません。&quot;}); } }; module.exports = { /** * ユーザー管理画面を開く。 */ index : function(req, res) { logger.trace(req, &quot;index called&quot;); openUserManageIndexPage(req, res, null); }, /** * ユーザー作成画面を開く */ openCreate : function(req, res) { logger.trace(req, &quot;openCreate called&quot;); var loginInfo = Utility.getLoginInfo(req, res); // 管理者のみはユーザー作成画面を開くことができる。 if(loginInfo[&quot;roleName&quot;] !== &quot;admin&quot;){ logger.warn(req, &quot;ユーザー作成画面オープン 失敗: [管理者権限なし]&quot;); Utility.openMainPage(req, res, {type: &quot;warn&quot;, contents: &quot;ユーザーを作成できません。&quot;}); return; } logger.debug(req, &quot;ユーザー作成画面オープン 成功&quot;); res.view({ username: &quot;&quot;, nickname: &quot;&quot;, password: &quot;&quot;, password_confirm : &quot;&quot;, loginInfo: loginInfo, valid: &quot;&quot;, role: &quot;&quot; }); }, /** * ユーザー作成処理 */ createUser : function(req, res) { logger.trace(req, &quot;createUser called&quot;); var loginInfo = Utility.getLoginInfo(req, res); // 管理者のみユーザーを作成できる。 if(loginInfo[&quot;roleName&quot;] !== &quot;admin&quot;){ logger.warn(req, &quot;ユーザー作成処理 失敗: [管理者権限なし]&quot;); Utility.openMainPage(req, res, {type: &quot;warn&quot;, contents: &quot;ユーザーを作成できません。&quot;}); return; } // ユーザー作成処理 User.create({ username: req.param('username'), password: req.param('password'), nickname: req.param('nickname'), role: req.param('role'), projectId: loginInfo[&quot;projectId&quot;], // 当該ユーザーを作成した管理者のプロジェクトＩＤを引き継ぐ flag1: req.param('valid') }).exec(function(err, obj) { if(err){ // エラー発生時には入力値を保持したまま、ユーザー作成画面を再表示する。 logger.error(req, &quot;ユーザー作成処理 失敗: [&quot; + JSON.stringify(err) + &quot;]&quot;); loginInfo.message = {type : &quot;danger&quot;, contents : &quot;システムエラーが発生しました。&quot;}; res.view(&quot;usermanage/openCreate&quot;, { username: req.param('username'), nickname: req.param('nickname'), password: req.param('password'), password_confirm : req.param('password_confirm'), loginInfo: loginInfo, valid: req.param('valid'), role: req.param('role') }); return; } logger.info(req, &quot;ユーザー作成処理 成功: [&quot; + JSON.stringify(obj) + &quot;]&quot;); // 正常終了の場合、ユーザー管理画面に遷移する。 openUserManageIndexPage(req, res, {type: &quot;success&quot;, contents: &quot;ユーザーを作成しました。&quot;}); }); }, /** * ユーザー削除処理 */ destroyUser : function(req, res) { var target = req.param('target'); logger.trace(req, &quot;destroyUser called: [&quot; + target+ &quot;]&quot;); logger.info(req, &quot;ユーザー削除処理: 対象ユーザー[&quot; + target+ &quot;]&quot;); var loginInfo = Utility.getLoginInfo(req, res); // 管理者のみユーザーを削除することができる。 if(loginInfo[&quot;roleName&quot;] !== &quot;admin&quot;){ logger.warn(req, &quot;ユーザー削除処理 失敗: [管理者権限なし]&quot;); Utility.openMainPage(req, res, {type: &quot;warn&quot;, contents: &quot;ユーザーを削除できません。&quot;}); return; } // 指定されたユーザーIDを持つユーザーを削除する。 // 削除対象ユーザーIDが指定されていない場合には、処理を行わずにユーザー一覧画面に遷移する。 if(target){ // 同一プロジェクトＩＤのユーザーでない場合には処理を中断する User.findOne(target).exec(function(err, obj) { if(err || !obj || obj.length === 0 || loginInfo[&quot;projectId&quot;] !== obj[&quot;projectId&quot;]){ // 削除処理に失敗した場合には、ユーザ一覧画面に遷移する。 logger.error(req, &quot;ユーザー削除処理 失敗(同一プロジェクトＩＤ判定): [&quot; + JSON.stringify(err) + &quot;]&quot;); openUserManageIndexPage(req, res, {type:&quot;danger&quot;, contents:&quot;ユーザー削除処理に失敗しました。&quot;}); return; } User.destroy(target).exec(function(err, obj) { // 以下、ハッシュ化したパスワードが表示されるため通常コメントアウト。 // logger.info(&quot;ユーザー削除結果[&quot; + JSON.stringify(obj) + &quot;]&quot;); if(err || !obj || obj.length === 0){ // 削除処理に失敗した場合には、ユーザ一覧画面に遷移する。 logger.error(req, &quot;ユーザー削除処理 失敗: [&quot; + JSON.stringify(err) + &quot;]&quot;); openUserManageIndexPage(req, res, {type:&quot;danger&quot;, contents:&quot;ユーザー削除処理に失敗しました。&quot;}); return; } logger.info(req, &quot;ユーザー削除処理 成功: [&quot; + JSON.stringify(obj) + &quot;]&quot;); openUserManageIndexPage(req, res, {type: &quot;success&quot;, contents: &quot;ユーザー&quot; + obj[0][&quot;username&quot;] + &quot;(&quot; + obj[0][&quot;nickname&quot;] + &quot;)を削除しました。&quot;}); }); }); } else { logger.warn(req, &quot;ユーザー削除処理 失敗: [削除ユーザーIDが未設定]&quot;); // 通常操作で発生しないため、メッセージを表示せずユーザー管理画面に遷移。。 res.redirect('/usermanage/index'); } }, /** * ユーザー更新処理 */ updateUser : function(req, res) { // ユーザー一覧で指定されたID var target = req.param('target'); logger.trace(req, &quot;updateUser called: [&quot; + target + &quot;]&quot;); logger.info(req, &quot;ユーザー更新処理: 対象ユーザー[&quot; + target+ &quot;]&quot;); var loginInfo = Utility.getLoginInfo(req, res); // ユーザーIDが未設定、もしくは、管理者以外が自分以外のユーザー情報の更新を試みた場合にはエラーとする。 // (利用するDBによってはIDが数値となるため、いったん文字列に変換してから判定する。) if(!target || (loginInfo[&quot;roleName&quot;] !== &quot;admin&quot; &amp;&amp; String(target) != String(loginInfo[&quot;id&quot;]))){ logger.warn(req, &quot;ユーザー更新処理 失敗: [権限不適合:&quot; + target + &quot;,&quot; + JSON.stringify(loginInfo) + &quot;]&quot;); Utility.openMainPage(req, res, {type: &quot;warn&quot;, contents: &quot;更新対象ユーザーIDが不正です&quot;}); return; } User.findOne(target).exec(function(err, oldUser) { // 以下、ハッシュ化したパスワードが表示されるため通常コメントアウト。 // logger.info(&quot;更新ユーザー検索結果[&quot; + JSON.stringify(oldUser) + &quot;]&quot;); // エラー発生、更新対象ユーザーが存在しない場合、プロジェクトＩＤが異なる場合、 // ユーザー管理画面に遷移し、メッセージを表示する。 // （検索結果が存在しない場合には、targetはundefinedが設定される。） if(err || !oldUser || loginInfo[&quot;projectId&quot;] != oldUser[&quot;projectId&quot;]){ logger.error(req, &quot;ユーザー更新処理 ユーザー情報取得 失敗: [&quot; + JSON.stringify(err) + &quot;]&quot;); openUserManageIndexPage(req, res, {type:&quot;danger&quot;, contents: &quot;ユーザの更新に失敗しました。&quot;}); return; } // 更新対象ユーザーが存在する場合には、更新用データを作成。 var newData = {}; var newUsername = req.param('username'); var newPassword = req.param('password'); var newNickname = req.param('nickname'); var role = req.param('role'); var valid = req.param('valid'); // 変更された項目に値を設定する。 if(oldUser[&quot;username&quot;] !== newUsername){ newData[&quot;username&quot;] = newUsername; } if(newPassword){ var shasum = crypto.createHash('sha1'); shasum.update(newPassword); var hashed = shasum.digest('hex'); newData[&quot;password&quot;] = hashed; } if(oldUser[&quot;nickname&quot;] !== newNickname){ newData[&quot;nickname&quot;] = newNickname; } if(role != null) { newData[&quot;role&quot;] = role; } if(valid != null) { newData[&quot;flag1&quot;] = valid; } // 以下、ハッシュ化したパスワードが表示されるため通常コメントアウト。 // logger.debug(&quot;更新ユーザー情報[&quot; + JSON.stringify(newData)); User.update({id:target}, newData).exec(function(err, obj) { // 以下、ハッシュ化したパスワードが表示されるため通常コメントアウト。 // logger.debug(&quot;ユーザー更新結果[&quot; + JSON.stringify(obj) +&quot;]&quot;); if(err) { logger.error(req, &quot;ユーザー情報更新 更新処理 失敗: [&quot; + JSON.stringify(err) +&quot;]&quot;); // TODO: エラーメッセージの内容を検討する。 loginInfo.message = {type: &quot;danger&quot;, contents: &quot;システムエラーが発生しました。&quot;+JSON.stringify(err)}; res.view(&quot;usermanage/openCreate&quot;, { username: req.param('username'), nickname: req.param('nickname'), password: req.param('password'), password_confirm : req.param('password_confirm'), loginInfo: loginInfo, valid: req.param('valid'), role: req.param('role') }); return; } logger.info(req, &quot;ユーザー情報更新 成功: [&quot; + JSON.stringify(obj) +&quot;]&quot;); var message = {type:&quot;success&quot;, contents: &quot;ユーザー情報を更新しました。&quot;}; var role = loginInfo[&quot;roleName&quot;]; var next; if(role === 'admin') { openUserManageIndexPage(req, res, message); } else { Utility.openMainPage(req, res, message); } }); }); }, /** * ユーザー情報更新画面を開く */ openUpdateUser : function(req, res) { var id = req.param(&quot;target&quot;); logger.trace(req, &quot;openUpdateUser called: [&quot; + id + &quot;]&quot;); var loginInfo = Utility.getLoginInfo(req, res); // ユーザーIDが未設定、もしくは、管理者以外が自分以外のユーザー情報の更新を試みた場合にはエラーとする。 // (利用するDBによってはIDが数値となるため、いったん文字列に変換してから判定する。) if(!id || (loginInfo[&quot;roleName&quot;] !== &quot;admin&quot; &amp;&amp; String(id) !== String(loginInfo[&quot;id&quot;]))){ // 管理者以外は他ユーザーのユーザー情報を更新することができない。 logger.warn(req, &quot;ユーザー情報画面オープン 失敗: [権限不適合:&quot; + id + &quot;,&quot; + JSON.stringify(loginInfo) + &quot;]&quot;); Utility.openMainPage(req, res, {type: &quot;warn&quot;, contents: &quot;更新対象ユーザーIDが不正です&quot;}); return; } User.findOne(id).exec(function(err, found){ // 同一プロジェクトＩＤでない場合にはエラーとする。 if(err || !found || loginInfo[&quot;projectId&quot;] != found[&quot;projectId&quot;]) { logger.error(req, &quot;ユーザー情報更新画面オープン 失敗: [&quot; + JSON.stringify(err) +&quot;]&quot;); Utility.openMainPage(req, res, {type: &quot;danger&quot;, contents: &quot;ユーザー情報更新画面の表示に失敗&quot;}); return; } logger.debug(req, &quot;ユーザー情報更新画面オープン 成功&quot;); res.view({username: found[&quot;username&quot;], nickname: found[&quot;nickname&quot;], target: id, loginInfo: loginInfo, valid: found[&quot;flag1&quot;], role: found[&quot;role&quot;] }); }); }, }; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Global Members crypto :: TODO: You might write a short summary of how this model works and what it represents here. Source: models/User.js, line 8 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto KPTボード###【利用方法】 必要なアプリケーションの準備プロダクションモードで起動する場合にはmongodbをインストールする。下記【mongodbの準備と利用方法】参照。動作確認環境の例）Windows 7 32bit, node.js v.0.10.26, mongodb v.2.6.3 パッケージインストール適宜必要なパッケージをインストールする。dashboard直下で、npm installを実行する。（もしくは、既にダウンロードしたnode_modulesディレクトリをアプリルートディレクトリ直下にコピー。） デフォルト管理アカウントの設定config/bootstrap.js内のデフォルト管理アカウントを適宜修正。▲パスワードを平文として含むため取扱に注意。Sails.js起動時、指定したデフォルト管理アカウントが存在しない場合に作成する。 Sails起動アプリルートディレクトリ直下で以下のコマンドを実行： developmentモードで起動する場合：sails lift（.tmpディレクトリ内にDBデータが格納されます。） productionモードで起動する場合：sails lift --prod（この場合、別途mongodbが起動している必要があります。 下記、【mongodbの準備と利用方法】を参照。） ポートを変更したい場合（例：1338ポートで起動する）sails lift --port 1338 利用するmongodbのデータベース名を変更したい場合（例：testを利用する）プロジェクト直下のconfigフォルダに、local.jsファイルを作成する。内容は以下：module.exports.connections = { mongodbServer : { database : 'test'}} ログインhttp://localhost:1337/loginにアクセスしてログインして、ボード作成、チケット作成などの機能を利用する。項目２で定義した値が管理アカウントの初期値となる。 id=username パスワード=password ###【mongodbの準備と利用方法】### 準備（productionモードで実行する場合にのみ必要）KPT-Bordでは、必要に応じてmongodbと組み合わせて利用できます。 mongodbのzip版をダウンロードして適当な場所に展開し、binフォルダをPATHに追加する。 mongodbのデータ格納フォルダを作成する。 以下のコマンドでmongodbを起動する：mongod --dbpath （データ格納フォルダパス） mongodb 利用方法 mongodbクライアントを起動する。mongo 利用するDBを選択：use sails コマンドの例 以下のコマンドでticketコレクションのリストを表示db.ticket.find() 以下のコマンドでticketコレクションにデータをインサート：db.ticket.insert({name:'name01', message:'MESSAGE01', ...}); ###ライセンス####Copyright © 2014 New Technology WorkshopLicensed under the MIT License.http://www.opensource.org/licenses/mit-license.php × Search results Close "},"module-AuthController%20%E8%AA%8D%E8%A8%BC%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC.html":{"id":"module-AuthController%20%E8%AA%8D%E8%A8%BC%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC.html","title":"Module: AuthController 認証コントローラー","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Module: AuthController 認証コントローラー :: Server-side logic for managing Auths Source: controllers/AuthController.js, line 1 × Search results Close "},"module-BoardController%20%E3%83%9C%E3%83%BC%E3%83%89%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC.html":{"id":"module-BoardController%20%E3%83%9C%E3%83%BC%E3%83%89%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC.html","title":"Module: BoardController ボードコントローラー","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Module: BoardController ボードコントローラー :: Server-side logic for managing Boards Source: controllers/BoardController.js, line 1 Methods &lt;static&gt; createBoard() ボード作成 Source: controllers/BoardController.js, line 970 &lt;static&gt; deleteBoard() ボード情報削除 Source: controllers/BoardController.js, line 986 &lt;static&gt; listBoard() ボード一覧取得 Source: controllers/BoardController.js, line 994 &lt;static&gt; listTicket() チケット一覧取得 Source: controllers/BoardController.js, line 1100 &lt;static&gt; process(req, res) チケット共通処理. Parameters: Name Type Description req リクエスト res レスポンス Source: controllers/BoardController.js, line 1007 &lt;static&gt; register() リスナ登録 Source: controllers/BoardController.js, line 949 &lt;static&gt; updateBoard() ボード情報更新 Source: controllers/BoardController.js, line 978 &lt;inner&gt; createBoardInner(req, res, cb) ボード作成内部処理. Parameters: Name Type Description req リクエスト res レスポンス cb 呼び出し方式（ブラウザ/REST）に応じて処理を分岐するためのコールバック関数 Source: controllers/BoardController.js, line 207 &lt;inner&gt; createTicket(req, res, cb, loginInfo, boardId) チケット作成処理. Parameters: Name Type Description req リクエスト res レスポンス cb 結果処理コールバック loginInfo ログイン情報 boardId ボードＩＤ Source: controllers/BoardController.js, line 567 &lt;inner&gt; deleteBoardInner() ボード削除処理 Source: controllers/BoardController.js, line 423 &lt;inner&gt; deleteTicket(req, res, cb, loginInfo, boardId) チケット削除処理. Parameters: Name Type Description req リクエスト res レスポンス cb 結果処理コールバック loginInfo ログイン情報 boardId ボードＩＤ Source: controllers/BoardController.js, line 638 &lt;inner&gt; getBrowserCallback(req, res, params) ブラウザから呼び出された場合に利用するコールバック関数. Parameters: Name Type Description req リクエスト res レスポンス params パラメータ Source: controllers/BoardController.js, line 25 &lt;inner&gt; getCallback(req, res) 結果処理コールバック関数取得. ブラウザからの呼び出しか、RESTからの呼び出し化を判断し、適切なコールバック関数を返却する。 Parameters: Name Type Description req リクエスト res レスポンス Source: controllers/BoardController.js, line 126 Returns: 結果処理コールバック関数 &lt;inner&gt; getRESTCallback(req, res, params) RESTから呼び出された場合に利用するコールバック関数. Parameters: Name Type Description req リクエスト res レスポンス params パラメータ Source: controllers/BoardController.js, line 97 &lt;inner&gt; listBoardInner() ボード一覧取得処理 Source: controllers/BoardController.js, line 499 &lt;inner&gt; listTicketInner() チケット一覧取得処理 Source: controllers/BoardController.js, line 847 &lt;inner&gt; moveTicket(req, res, cb, loginInfo, boardId) チケット移動処理. チケットをボードから別なボードに移動する。 Parameters: Name Type Description req リクエスト res レスポンス cb 結果処理コールバック loginInfo ログイン情報 boardId ボードＩＤ Source: controllers/BoardController.js, line 767 &lt;inner&gt; updateBoardInner(req, res, cb) ボード更新内部処理. Parameters: Name Type Description req リクエスト res レスポンス cb 呼び出し方式（ブラウザ/REST）に応じて処理を分岐するためのコールバック関数 Source: controllers/BoardController.js, line 295 &lt;inner&gt; updateTicket(req, res, cb, loginInfo, boardId) チケット更新処理. Parameters: Name Type Description req リクエスト res レスポンス cb 結果処理コールバック loginInfo ログイン情報 boardId ボードＩＤ Source: controllers/BoardController.js, line 697 × Search results Close "},"module-DashboardController%20%E3%83%9C%E3%83%BC%E3%83%89%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC%EF%BC%92.html":{"id":"module-DashboardController%20%E3%83%9C%E3%83%BC%E3%83%89%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC%EF%BC%92.html","title":"Module: DashboardController ボードコントローラー２","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Module: DashboardController ボードコントローラー２ :: Server-side logic for managing dashboards Source: controllers/DashboardController.js, line 1 Methods &lt;static&gt; createBoard() ボード作成画面を開く Source: controllers/DashboardController.js, line 474 &lt;static&gt; deleteImageFile() ファイル削除処理 Source: controllers/DashboardController.js, line 529 &lt;static&gt; editBoard() ボード情報変更画面を開く Source: controllers/DashboardController.js, line 463 &lt;static&gt; index() ボード一覧画面を開く Source: controllers/DashboardController.js, line 215 &lt;static&gt; openBoard2() ボード画面を開く Source: controllers/DashboardController.js, line 314 &lt;static&gt; uploadImageFile() ファイルのアップロード Source: controllers/DashboardController.js, line 482 &lt;inner&gt; addMainClassName() チケット個別スタイル情報ファイルの内容からスタイルHTMLを作成する。 各行の先頭にクラス名を追加する。空行は無視する。 Source: controllers/DashboardController.js, line 642 &lt;inner&gt; createComboMenu(displayTickets) コンボボックスメニューHTML作成 Parameters: Name Type Description displayTickets 対象ボードで利用可能なチケットタイプのリスト Source: controllers/DashboardController.js, line 676 Returns: HTML文字列 &lt;inner&gt; createContextMenu(displayTickets) コンテクストメニューHTML作成 Parameters: Name Type Description displayTickets 対象ボードで利用可能なチケットタイプのリスト Source: controllers/DashboardController.js, line 688 Returns: HTML文字列 &lt;inner&gt; createCss(list) チケット個別スタイルを生成 Parameters: Name Type Description list チケットタイプリスト Source: controllers/DashboardController.js, line 629 Returns: スタイル文字列 Type String &lt;inner&gt; createCssOfImage(ticketType) チケット単位の個別スタイル生成 Parameters: Name Type Description ticketType チケットタイプ Source: controllers/DashboardController.js, line 660 Returns: スタイル文字列 Type String &lt;inner&gt; createTicketDataArray(ticketData2) 利用可能付箋データ文字列を配列に変換する。 Parameters: Name Type Description ticketData2 利用可能付箋データ文字列 Source: controllers/DashboardController.js, line 99 Returns: 利用可能付箋データ配列 Type Array &lt;inner&gt; createTicketTypeString(req, ticketData2) 利用可能付箋タイプ一覧のデータを作成する。 Parameters: Name Type Description req ticketData2 Source: controllers/DashboardController.js, line 78 Returns: Type String &lt;inner&gt; isImageFile(file) 画像ファイルか否かを判定する。 Parameters: Name Type Description file ファイル名 Source: controllers/DashboardController.js, line 614 Returns: 画像ファイルであればtrue, そうでない場合はfalse. × Search results Close "},"module-NewBoardController%20%E3%83%9C%E3%83%BC%E3%83%89%E6%96%B0%E8%A6%8F%E4%BD%9C%E6%88%90%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC.html":{"id":"module-NewBoardController%20%E3%83%9C%E3%83%BC%E3%83%89%E6%96%B0%E8%A6%8F%E4%BD%9C%E6%88%90%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC.html","title":"Module: NewBoardController ボード新規作成コントローラー","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Module: NewBoardController ボード新規作成コントローラー :: Server-side logic for managing Newboards Source: controllers/NewBoardController.js, line 1 × Search results Close "},"module-RESTController%20REST%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC.html":{"id":"module-RESTController%20REST%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC.html","title":"Module: RESTController RESTコントローラー","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Module: RESTController RESTコントローラー :: Server-side logic for managing Auths Source: controllers/RESTController.js, line 1 Methods &lt;static&gt; createBoard() ボード作成API. Source: controllers/RESTController.js, line 235 &lt;static&gt; createTicket() チケット作成API. Source: controllers/RESTController.js, line 199 &lt;static&gt; deleteBoard() ボード削除API. Source: controllers/RESTController.js, line 276 &lt;static&gt; deleteTicket() チケット削除API. Source: controllers/RESTController.js, line 208 &lt;static&gt; getToken() 認証トークン生成. POSTで送られたユーザー名、パスワードから認証トークンを生成する。 Source: controllers/RESTController.js, line 146 &lt;static&gt; listBoard() ボード一覧取得API. REST API利用方法 URL: http://(IPアドレス):(ポート番号)/api/board アクション: GET 入力項目 キー説明必須備考 token認証トークン○ idボードID指定したボードIDをもつボードのみ取得 titleボードタイトル指定したタイトルをもつボードのみ取得 出力項目 キー説明備考 success処理結果。処理に成功した場合はtrue、それ以外の場合はfalse. message結果メッセージ board指定したプロジェクトに存在するボード情報リスト Source: controllers/RESTController.js, line 318 &lt;static&gt; listTicket() チケット一覧取得API. URL: http://(IPアドレス):(ポート番号)/api/ticket アクション: GET 入力必須項目 キー説明必須備考 token認証トークン○ boardIdボードID＊１＊１: ボードID、もしくは、ボードタイトルのいずれかが必要 boardTitleボードタイトル＊１ 出力項目 キー説明備考 success処理結果。処理に成功した場合はtrue、それ以外の場合はfalse. message結果メッセージ ticket指定したボードに存在するチケット情報リスト 実行例 curl &quot;http://localhost:1337/api/board?token=(認証トークン文字列)&amp;projectId=P01&quot; Source: controllers/RESTController.js, line 361 &lt;static&gt; moveTicket() チケット移動API. Source: controllers/RESTController.js, line 226 &lt;static&gt; updateBoard() ボード更新API. Source: controllers/RESTController.js, line 255 &lt;static&gt; updateTicket() チケット更新API. Source: controllers/RESTController.js, line 217 &lt;inner&gt; authenticate(username, password, cb) REST認証処理. ユーザーID, パスワード認証を行う。 Parameters: Name Type Description username ユーザーID password パスワード cb コールバック処理 Source: controllers/RESTController.js, line 29 &lt;inner&gt; authenticateToken(req, cb) 認証トークンの妥当性検証. 認証トークンをデコードし、妥当性を検証する。エラーが発生した場合には、第１引数にエラー内容を設定してコールバック関数を実行。妥当である場合には、第２引数にデコード結果を設定してコールバック関数を実行。 Parameters: Name Type Description req リクエスト cb コールバック関数 Source: controllers/RESTController.js, line 79 × Search results Close "},"module-UserManageController%20%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E7%AE%A1%E7%90%86%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC.html":{"id":"module-UserManageController%20%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E7%AE%A1%E7%90%86%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9%E3%83%BC.html","title":"Module: UserManageController ユーザー管理コントローラー","body":" DocStrap Modules AuthController 認証コントローラーBoardController ボードコントローラーDashboardController ボードコントローラー２NewBoardController ボード新規作成コントローラーRESTController RESTコントローラーUserManageController ユーザー管理コントローラー Global crypto Module: UserManageController ユーザー管理コントローラー :: Server-side logic for managing Usermanages Source: controllers/UserManageController.js, line 1 Methods &lt;static&gt; createUser() ユーザー作成処理 Source: controllers/UserManageController.js, line 80 &lt;static&gt; destroyUser() ユーザー削除処理 Source: controllers/UserManageController.js, line 124 &lt;static&gt; index() ユーザー管理画面を開く。 Source: controllers/UserManageController.js, line 47 &lt;static&gt; openCreate() ユーザー作成画面を開く Source: controllers/UserManageController.js, line 55 &lt;static&gt; openUpdateUser() ユーザー情報更新画面を開く Source: controllers/UserManageController.js, line 266 &lt;static&gt; updateUser() ユーザー更新処理 Source: controllers/UserManageController.js, line 172 &lt;inner&gt; openUserManageIndexPage() ユーザー管理画面を開く Source: controllers/UserManageController.js, line 15 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
